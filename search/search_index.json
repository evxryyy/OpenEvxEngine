{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#api-presentation","title":"API Presentation","text":"<p>To begin, this open-source library was created in mid-August 2025 by @Evxry (me) to give  Roblox developers more ease but also more performance gains when developing games  (small or large).</p> <p>Precautions</p> <p>Most of these files are often updated with each module. At the beginning of the page,  the latest version will be displayed. Please verify carefully.</p>"},{"location":"#module-list","title":"Module List","text":"Module Description <code>Buffer</code>  Powerful library to write, serialize/deserialize,read data with the \"buffer\" type <code>UserInput</code>  Input handling system for keyboard,gamepad, and mouse input with dynamic switching <code>ASCII</code>  Binary and ASCII Conversion Utilities <code>Nexus</code>  Networking <code>Socket</code>  Buffer Networking <code>Task</code>  Old garbage collection/cleanup utility module <code>Collect</code>  Improved garbage collection/cleanup utility module <code>Enum</code>  System for creating and managing enums <code>Option</code>  Implements the Option type pattern <code>ConnectionStore</code>  Store RBXScriptConnection,callback and thread"},{"location":"#who-this-library-is-for","title":"Who This Library Is For","text":"<p>This library mainly targets people who want to create their own complete system, for example  a secure ECS for all data, remotes, security, etc. If you just want an easy-to-use library that does everything for you, this is not for you.</p>"},{"location":"#additional-information","title":"Additional Information","text":"<p>People can modify and publish this library, BUT they must send me a Discord message so I can  give them permission to publish.</p>"},{"location":"#links","title":"Links","text":"<p>Roblox Profile</p> <p>Github Profile</p> <p>Discord User : .d_0010"},{"location":"API/ASCII/","title":"Overview","text":""},{"location":"API/ASCII/#getting-started","title":"Getting Started","text":"<p>ASCII is a module that allows for binary or ASCII conversions with strings.</p>"},{"location":"API/ASCII/#version","title":"Version","text":""},{"location":"API/ASCII/#ascii-v11","title":"ASCII V1.1","text":""},{"location":"API/ASCII/Methods/","title":"Methods","text":""},{"location":"API/ASCII/Methods/#getting-started","title":"Getting Started","text":"<p>All methods for the ASCII module will be here.</p>"},{"location":"API/ASCII/Methods/#methods","title":"Methods","text":""},{"location":"API/ASCII/Methods/#strings-convertion","title":"Strings Convertion","text":"<p>For conversion with strings, methods such as <code>ConvertASCIIString</code> and <code>ConvertNumsToString</code> will be used.</p>"},{"location":"API/ASCII/Methods/#string-to-ascii-numbers","title":"String to ASCII Numbers","text":"<pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal str = \"Hello World !\"\n\nprint(ASCII.ConvertASCIIString(str)) --&gt; ARRAY_OF_NUMBERS\n</code></pre> <p>This will convert the string into an array of numbers where each number represents a letter.</p>"},{"location":"API/ASCII/Methods/#ascii-numbers-to-string","title":"ASCII Numbers to String","text":"<pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal nums = ASCII.ConvertASCIIString(\"Hello World !\")\n\nprint(ASCII.ConvertNumsToString(nums)) --&gt; ORIGINAL_STRING\n</code></pre> <p>This will return the original string, meaning \"Hello World!\".</p>"},{"location":"API/ASCII/Methods/#binary-convertion","title":"Binary Convertion","text":"<p>For converting numbers to binary, functions such as <code>ConvertNumberToBinary</code> and <code>ConvertBinaryToNumber</code> will be used.</p>"},{"location":"API/ASCII/Methods/#number-to-binary","title":"Number to Binary","text":"NumberArray of numbers <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal num = 10\nlocal b = ASCII.ConvertNumberToBinary(num)\n\nprint(b) --&gt; return a buffer\n</code></pre> <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal nums = {10,5,1}\nlocal b = ASCII.ConvertNumberToBinary(nums)\n\nprint(b) --&gt; return an array of buffer\n</code></pre>"},{"location":"API/ASCII/Methods/#binary-to-number","title":"Binary to Number","text":"BufferArray of bufferArray of Buffer 'Merge Option' <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal nums = 10\nlocal b = ASCII.ConvertNumberToBinary(nums)\n\nlocal backToNumbers = ASCII.ConvertBinaryToNumber(b)\nprint(backToNumbers) --&gt; will print the number back so 10\n</code></pre> <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal nums = {10,5,1}\nlocal b = ASCII.ConvertNumberToBinary(nums)\n\nlocal backToNumbers = ASCII.ConvertBinaryToNumber(b)\nprint(backToNumbers) --&gt; will print the number back so {10,5,1}\n</code></pre> <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal nums = {10,5,1}\nlocal b = ASCII.ConvertNumberToBinary(nums)\n\nlocal backToNumbers = ASCII.ConvertBinaryToNumber(b,\"Merge\")\nprint(backToNumbers) --&gt; will print the number 171 cause all buffer (in order) will be merged\n</code></pre> <p>Warning</p> <p>Option are optional but for 'Single' this will simply return a table of all numbers</p>"},{"location":"API/Buffer/","title":"Buffer","text":""},{"location":"API/Buffer/#overview","title":"Overview","text":"<p>Buffer is a module for writing compressed data to improve performance when needed. The module also includes methods for serializing and deserializing data, as well as some utilities like Buffer.Enum, Buffer.Constants, and Buffer.Utils.</p>"},{"location":"API/Buffer/#version","title":"Version","text":""},{"location":"API/Buffer/#buffer-v29","title":"Buffer V2.9","text":""},{"location":"API/Buffer/#getting-started","title":"Getting Started","text":"<p>Note</p> <ul> <li>This module should be used with caution as it can be easy to deserialize a buffer without a predefined schema</li> <li>The buffer inside the component can be encrypted if you really want to ensure its security</li> </ul> <p>This module can be somewhat complicated to use if you are not familiar with buffers or directly with bytes/bits.</p>"},{"location":"API/Buffer/#data-type","title":"Data-type","text":"<p>Buffer contains over 30 data types. Find each type here:</p> <ul> <li>List of data-type<ul> <li> Signed-Int</li> <li> Unsigned-Int</li> <li> Float</li> <li> Roblox Types</li> </ul> </li> </ul>"},{"location":"API/Buffer/#signed-int","title":"Signed-Int","text":"Type Min-Max <code>I1</code> -1 to 1 <code>I8</code> -128 to 127 <code>I16</code> -32,768 to 32,767 <code>I24</code> -8,388,608 to 8,388,607 <code>I32</code> -2,147,483,648 to 2,147,483,647 <code>I40</code> -549,755,813,888 to 549,755,813,887 <code>I48</code> -140,737,488,355,328 to 140,737,488,355,327 <code>I54</code> -9,007,199,254,740,992 to 9,007,199,254,740,991"},{"location":"API/Buffer/#unsigned-int","title":"Unsigned-Int","text":"Type Min-Max <code>U1</code> 0 to 1 <code>U8</code> 0 to 255 <code>U16</code> 0 to 65,535 <code>U24</code> 0 to 16,777,215 <code>U32</code> 0 to 4,294,967,295 <code>U40</code> 0 to 1,099,511,627,775 <code>U48</code> 0 to 281,474,976,710,655 <code>U54</code> 0 to 18,014,398,509,481,980"},{"location":"API/Buffer/#float","title":"Float","text":"Type Description <code>F16</code> Half-precision float <code>F32</code> Single-precision float <code>F64</code> Double-precision float"},{"location":"API/Buffer/#roblox-types","title":"Roblox Types","text":"Type Description <code>Bool1</code> 1-bit <code>Bool8</code> 8-bit (each bool cost 1 bit) <code>Strings</code> With various length limits: 8, 16, 32, 64 chars or unlimited <code>Color3</code> RGB <code>Vector2</code> X,Y (16 bytes) <code>Vector3</code> X,Y,Z (24 bytes) <code>Vector2Int16</code> X,Y (4 bytes) <code>Vector3Int16</code> X,Y,Z (6 bytes) <code>CFrame</code> 96 bytes <code>LossyCFrame</code> Compressed version of CFrame (48 bytes) <code>UDim</code> Scale,Offset (8 bytes) <code>UDim2</code> X.Scale, Y.Scale, X.Offset, Y.Offset  (16 bytes) <code>Rect</code> 32 bytes <code>Region3</code> 120 bytes <code>Region3Int16</code> 16 bytes <code>Instance</code> Stored in a separate instance buffer <code>vector</code> luau vector library (24 byte) <code>Enum</code> Roblox EnumItem (4 byte) <code>NumberRange</code> 8 <code>FloatCurveKey</code> 16 or 24 <code>(if you use KeyInterpolationMode.Cubic)</code> <code>RotationCurveKey</code> 104 or 112 <code>(if you use KeyInterpoliationMode.Cubic)</code> <code>ColorSequence</code> 1 + 16 * number of <code>ColorSequenceKeypoint</code> <code>NumberSequence</code> 1 + 12 * number of <code>NumberSequenceKeypoint</code>"},{"location":"API/Buffer/#writing","title":"Writing","text":"<p>To write each data type, methods starting with <code>:Write</code> are used:</p> <p>Write Methods List :</p> <ul> <li> Write Signed-Int<ul> <li> Write I1</li> <li> Write I8</li> <li> Write I16</li> <li> Write I24</li> <li> Write I32</li> <li> Write I40</li> <li> Write I48</li> <li> Write I54</li> </ul> </li> <li> Write Unsigned-Int<ul> <li> Write U1</li> <li> Write U8</li> <li> Write U16</li> <li> Write U24</li> <li> Write U32</li> <li> Write U40</li> <li> Write U48</li> <li> Write U54</li> </ul> </li> <li> Write Float<ul> <li> Write F16</li> <li> Write F32</li> <li> Write F64</li> </ul> </li> <li> Write Roblox Types<ul> <li> Write Bool1</li> <li> Write Bool8</li> <li> Write Instance</li> <li> Write Vector2</li> <li> Write Vector3</li> <li> Write Vector2Int16</li> <li> Write Vector3Int16</li> <li> Write CFrame</li> <li> Write LossyCFrame</li> <li> Write UDim</li> <li> Write UDim2</li> <li> Write Color3</li> <li> Write Rect</li> <li> Write Region3</li> <li> Write Region3Int16</li> <li> Write vector (luau library)</li> <li> Write Enum</li> <li> Write RotationCurveKey</li> <li> Write FloatCurveKey</li> <li> Write ColorSequence</li> <li> Write NumberRange</li> <li> Write NumberSequence</li> </ul> </li> <li> Write Custom<ul> <li> WriteAs</li> <li> WriteArray</li> </ul> </li> </ul>"},{"location":"API/Buffer/#reading","title":"Reading","text":"<p>To read written values, methods like <code>:Read[TypeName]</code> will be used.</p> <p>Note</p> <p>The first argument for each Read is the offset, which is 0-based. Expect for ReadInstance which need to start at 1.</p> <p>Read Methods List :</p> <ul> <li> Read Signed-Int<ul> <li> Read I1</li> <li> Read I8</li> <li> Read I16</li> <li> Read I24</li> <li> Read I32</li> <li> Read I40</li> <li> Read I48</li> <li> Read I54</li> </ul> </li> <li> Read Unsigned-Int<ul> <li> Read U1</li> <li> Read U8</li> <li> Read U16</li> <li> Read U24</li> <li> Read U32</li> <li> Read U40</li> <li> Read U48</li> <li> Read U54</li> </ul> </li> <li> Read Float<ul> <li> Read F16</li> <li> Read F32</li> <li> Read F64</li> </ul> </li> <li> Read Strings<ul> <li> Read String</li> </ul> </li> <li> Read Roblox Type<ul> <li> Read Bool1</li> <li> Read Bool8</li> <li> Read Instance</li> <li> Read Vector2</li> <li> Read Vector3</li> <li> Read Vector2Int16</li> <li> Read Vector3Int16 </li> <li> Read CFrame</li> <li> Read LossyCFrame</li> <li> Read UDim</li> <li> Read UDim2</li> <li> Read Color3</li> <li> Read Rect</li> <li> Read Region3</li> <li> Read Region3Int16</li> <li> Read vector (luau library)</li> <li> Read Enum</li> <li> Read RotationCurveKey</li> <li> Read FloatCurveKey</li> <li> Read ColorSequence</li> <li> Read NumberRange</li> <li> Read NumberSequence</li> </ul> </li> <li> Read Custom<ul> <li> ReadAs</li> <li> ReadArray</li> </ul> </li> </ul>"},{"location":"API/Buffer/Advanced/","title":"Advanced","text":""},{"location":"API/Buffer/Advanced/#getting-started","title":"Getting Started","text":"<p>The buffer module contains metamethods to facilitate debugging, etc. Here are the buffer properties:</p> <p><code>.buffer</code> -&gt; current buffer for writings</p> <p><code>.offset</code> -&gt; current offset</p> <p><code>.instance_offset</code> -&gt; current offset for the instance_buffer</p> <p><code>.instance_buffer</code> -&gt; table containing the instances</p>"},{"location":"API/Buffer/Advanced/#metamethods","title":"Metamethods","text":""},{"location":"API/Buffer/Advanced/#__len","title":"__len","text":"<p>To get the buffer size more easily, you can use this:</p> <pre><code>local size = #bufferComponent\n</code></pre> <p>This will return the buffer size.</p>"},{"location":"API/Buffer/Advanced/#__tostring","title":"__tostring","text":"<p>When you print the component, instead of displaying a table it will show:</p> <pre><code>print(bufferComponent) -&gt; BufferComponent(Size : number)\n</code></pre>"},{"location":"API/Buffer/Advanced/#__add","title":"__add","text":"<p>__add metamethod for buffer resizing.</p> <ul> <li>Resizes the buffer by the specified number of bytes.</li> <li>Returns the updated BufferComponent instance.</li> </ul> <pre><code>--will increase the buffer size by 5\nbufferComponent += 5\n</code></pre>"},{"location":"API/Buffer/Advanced/#__mul","title":"__mul","text":"<p>Expands the underlying buffer by a numeric factor using the * operator.</p> <ul> <li>Allocates a new buffer of size modf(oldSize * value), float are not allowed.</li> <li>Copies the old contents into the new buffer (starting at offset 0).</li> <li>Keeps the same write offset.</li> <li>Returns the updated BufferComponent instance.</li> <li>Throws an error if the value is less than or equal to 1.</li> </ul> <pre><code>--will increase the buffer size by (current_size * 10)\nbufferComponent *= 10\n</code></pre>"},{"location":"API/Buffer/Advanced/#__call","title":"__call","text":"<p>Dynamic writer dispatch via __call.</p> <pre><code>bufferComponent(\"U32\", 10)\nbufferComponent(\"String\", \"hello\")\nbufferComponent(\"Boolean1\", true)\nbufferComponent(\"Float32\", 1.5)\nbufferComponent(\"FloatCurveKey\", key)\nbufferComponent(\"RotationCurveKey\", rKey)\nbufferComponent(\"ColorSequence\", cseq)\nbufferComponent(\"NumberSequence\", nseq)\nbufferComponent(\"vector\", v)\n</code></pre>"},{"location":"API/Buffer/Methods/","title":"Methods","text":""},{"location":"API/Buffer/Methods/#creating-component","title":"Creating Component","text":"<p>To create a buffer, you will need to use these methods listed below:</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(size : number?)\n</code></pre> <p>This will create a buffer of X bytes.</p> <p>Warning</p> <p>If the size is not set, the default value will be 0. You can always use <code>:allocate()</code> to increase the size.</p>"},{"location":"API/Buffer/Methods/#advanced","title":"Advanced","text":"<p>There are other ways to create a buffer, for example: with a string or simply with an existing buffer.</p> fromfromString <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.from(b : buffer)\n</code></pre> <p>Note</p> <p>Note that the buffer data is not lost, the offset is directly set to the buffer size. Please use <code>from</code> only when you know what you are doing.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.fromString(str : string)\n</code></pre> <p>This will use the <code>.from</code> method once the buffer is converted to a buffer.</p> <p>Warning</p> <p>Please use this method only if you know what you are doing.</p>"},{"location":"API/Buffer/Methods/#allocating-space","title":"Allocating space","text":"<p>When creating a buffer, you can later increase its size regardless of the method used. Whether you use <code>from</code> or <code>fromString</code>, you can always expand the buffer size with <code>:allocate</code>.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:allocate(size : number)\n</code></pre>"},{"location":"API/Buffer/Methods/#others","title":"Others","text":"<p>Other useful methods are available in the component.</p>"},{"location":"API/Buffer/Methods/#empty-component","title":"Empty Component","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal emptyBuffer = Buffer.Empty() -- or Buffer.empty()\n</code></pre> <p>This will create an empty Buffer</p>"},{"location":"API/Buffer/Methods/#compress","title":"Compress","text":"<pre><code>local my_buffer = Buffer.create(1000)\n\nlocal compressed_buffer = my_buffer:Compress(Enum.CompressionAlgorithm.Zstd)\nprint(compressed_buffer) --&gt; buffer\n</code></pre> <p>Return a compressed buffer with the target Compression Algorithm</p> <p>Info</p> <ul> <li>This function use <code>EncodingService:CompressBuffer()</code>. Please see the Roblox API for more infos</li> </ul> <p>Warning</p> <ul> <li>Do not use this for buffers smaller than 30 bytes or in the 30\u201350 bytes range.</li> </ul>"},{"location":"API/Buffer/Methods/#decompress-constructor","title":"Decompress (Constructor)","text":"<pre><code>local my_buffer = Buffer.create(1000)\n\nlocal compressed_buffer = my_buffer:Compress(Enum.CompressionAlgorithm.Zstd)\nlocal decompressed_buffer = Buffer.Decompress(compressed_buffer,Enum.CompressionAlgorithm.Zstd)\n\nprint(decompressed_buffer)\n</code></pre> <p>Return the decompressed buffer as an <code>BufferComponentClass</code> with the target Compression Algorithm.</p> <p>The buffer must be already compressed with the target Compression Algorithm.</p> <p>Info</p> <ul> <li>This function use <code>EncodingService:DecompressBuffer()</code>. Please see the Roblox API for more infos</li> </ul> <p>Warning</p> <ul> <li>Make sure you use the exact same Compression Algorithm as the compressed buffer.</li> </ul>"},{"location":"API/Buffer/Methods/#onoffsetchanged","title":"OnOffsetChanged","text":"<pre><code>local my_buffer = Buffer.create(10)\n\nmy_buffer:OnOffsetChanged(function(oldOffset, newOffset)\n    print(oldOffset,newOffset)\nend)\n\nmy_buffer:writei8(127)\n</code></pre> <p>Connects a callback to the OffsetChanged signal. The callback is called when the offset is changed.</p> <p>Return : <code>SignalConnection</code></p>"},{"location":"API/Buffer/Methods/#oninstanceoffsetchanged","title":"OnInstanceOffsetChanged","text":"<pre><code>local my_buffer = Buffer.create(10)\n\nmy_buffer:OnInstanceOffsetChanged(function(oldOffset, newOffset)\n    print(oldOffset,newOffset)\nend)\n\nmy_buffer:WriteInstance(workspace.Baseplate)\n</code></pre> <p>Connects a callback to the InstanceOffsetChanged signal. The callback is called when the instance offset is changed.</p> <p>Return : <code>SignalConnection</code></p>"},{"location":"API/Buffer/Methods/#oncapacitychanged","title":"OnCapacityChanged","text":"<pre><code>local my_buffer = Buffer.create(10)\n\nlocal connection = my_buffer:OnCapacityChanged(function(oldSize, newSize)\n    print(oldSize,newSize)\nend)\n\nmy_buffer += 5\nmy_buffer:allocate(5)\nmy_buffer *= 5\n\n--later\n\nconnection:Disconnect()\n</code></pre> <p>Connects a callback to the CapacityChanged signal. The callback is called when the capacity is changed.</p> <p>Info</p> <ul> <li>__mult can fire CapacityChanged same for __add</li> <li>:allocate can fire CapacityChanged</li> </ul> <p>Return : <code>SignalConnection</code></p>"},{"location":"API/Buffer/Methods/#getremainingspace","title":"GetRemainingSpace","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nprint(myBuffer:GetRemainingSpace()) --&gt; 4 cause we didn't write anything yet\n</code></pre> <p>return the actual remaining space of the current buffer</p>"},{"location":"API/Buffer/Methods/#getoffset","title":"GetOffset","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nprint(myBuffer:GetOffset())\n</code></pre> <p>return the actual offset of the buffer</p>"},{"location":"API/Buffer/Methods/#getinstanceoffset","title":"GetInstanceOffset","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nprint(myBuffer:GetInstanceOffset())\n</code></pre> <p>return the actual instance offset of the buffer</p>"},{"location":"API/Buffer/Methods/#getbuffer","title":"GetBuffer","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nprint(myBuffer:GetBuffer())\n</code></pre> <p>return the current buffer</p>"},{"location":"API/Buffer/Methods/#getinstancebuffer","title":"GetInstanceBuffer","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nprint(myBuffer:GetInstanceBuffer())\n</code></pre> <p>return the current instance buffer</p>"},{"location":"API/Buffer/Methods/#getbuffersize","title":"GetBufferSize","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nprint(myBuffer:GetBufferSize())\n</code></pre> <p>return the actual buffer size (not the written data size)</p>"},{"location":"API/Buffer/Methods/#copy","title":"Copy","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nlocal copy_myBuffer = myBuffer:Copy()\nprint(buff == copy_myBuffer) --&gt; false\n</code></pre> <p>Create and return a copy of the current BufferComponent</p>"},{"location":"API/Buffer/Methods/#clear","title":"Clear","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:Clear()\n</code></pre> <p>clear the instance_buffer and the buffer itself</p> <p>both offset will be set to 0.</p> <p>Note</p> <p>this return self allow you to chain method</p>"},{"location":"API/Buffer/Methods/#clearinstances","title":"ClearInstances","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:ClearInstances()\n</code></pre> <p>Clear the instance_buffer.</p> <p>instance_offset will be set to 0.</p> <p>Note</p> <p>this return self allow you to chain method</p>"},{"location":"API/Buffer/Methods/#clearbuffer","title":"ClearBuffer","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:ClearBuffer()\n</code></pre> <p>Clear the buffer.</p> <p>The buffer offset will be set to 0.</p> <p>Note</p> <p>this return self allow you to chain method</p>"},{"location":"API/Buffer/Methods/#disconnectallsignals","title":"DisconnectAllSignals","text":"<pre><code>my_buffer:DisconnectAllSignals()\n</code></pre> <p>Disconnect all signals <code>OnOffsetChanged</code>,<code>OnInstanceOffset</code>,<code>OnCapacityChanged</code></p>"},{"location":"API/Buffer/Methods/#destroy","title":"Destroy","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:Destroy()\n</code></pre> <p>Destroy the actual BufferComponent. You can't use the BufferComponent after this.</p>"},{"location":"API/Buffer/Methods/#alias","title":"Alias","text":"<p>Alias for the constructor and the component</p> <pre><code>--Constructor alias\nBufferConstructor.new = BufferConstructor.create\nBufferConstructor.New = BufferConstructor.create\n\nBufferConstructor.Empty = function() : BufferComponentClass\n    return BufferConstructor.create(0)\nend\nBufferConstructor.empty = BufferConstructor.Empty\n\nBufferConstructor.From = BufferConstructor.from\nBufferConstructor.FromString = BufferConstructor.fromString\nBufferConstructor.Tostring = BufferConstructor.tostring\n\nBufferConstructor.serialize = BufferConstructor.Serialize\nBufferConstructor.deserialize = BufferConstructor.Deserialize\n\nBufferConstructor.deserializeAll = BufferConstructor.DeserializeAll\nBufferConstructor.serializeAll = BufferConstructor.SerializeAll\n\nBufferConstructor.decompress = BufferConstructor.Decompress\n\nBufferConstructor.serializeCompressed = BufferConstructor.SerializeCompressed\nBufferConstructor.deserializeCompressed = BufferConstructor.DeserializeCompressed\n\nBufferConstructor.serializeAllCompressed = BufferConstructor.SerializeAllCompressed\nBufferConstructor.deserializeAllCompressed = BufferConstructor.DeserializeAllCompressed\n\n--Component alias\nBufferComponent.Allocate = BufferComponent.allocate\n\n--[Writer] signed interger alias\nBufferComponent.writeI1 = BufferComponent.WriteI1\nBufferComponent.writei1 = BufferComponent.WriteI1\n\nBufferComponent.writeI8 = BufferComponent.WriteI8\nBufferComponent.writei8 = BufferComponent.WriteI8\n\nBufferComponent.writeI16 = BufferComponent.WriteI16\nBufferComponent.writei16 = BufferComponent.WriteI16\n\nBufferComponent.writeI24 = BufferComponent.WriteI24\nBufferComponent.writei24 = BufferComponent.WriteI24\n\nBufferComponent.writeI32 = BufferComponent.WriteI32\nBufferComponent.writei32 = BufferComponent.WriteI32\n\nBufferComponent.writeI40 = BufferComponent.WriteI40\nBufferComponent.writei40 = BufferComponent.WriteI40\n\nBufferComponent.writeI48 = BufferComponent.WriteI48\nBufferComponent.writei48 = BufferComponent.WriteI48\n\nBufferComponent.writeI54 = BufferComponent.WriteI54\nBufferComponent.writei54 = BufferComponent.WriteI54\n\n--[Writer] unsigned interger alias\nBufferComponent.writeU1 = BufferComponent.WriteU1\nBufferComponent.writeu1 = BufferComponent.WriteU1\n\nBufferComponent.writeU8 = BufferComponent.WriteU8\nBufferComponent.writeu8 = BufferComponent.WriteU8\n\nBufferComponent.writeU16 = BufferComponent.WriteU16\nBufferComponent.writeu16 = BufferComponent.WriteU16\n\nBufferComponent.writeU24 = BufferComponent.WriteU24\nBufferComponent.writeu24 = BufferComponent.WriteU24\n\nBufferComponent.writeU32 = BufferComponent.WriteU32\nBufferComponent.writeu32 = BufferComponent.WriteU32\n\nBufferComponent.writeU40 = BufferComponent.WriteU40\nBufferComponent.writeu40 = BufferComponent.WriteU40\n\nBufferComponent.writeU48 = BufferComponent.WriteU48\nBufferComponent.writeu48 = BufferComponent.WriteU48\n\nBufferComponent.writeU54 = BufferComponent.WriteU54\nBufferComponent.writeu54 = BufferComponent.WriteU54\n\n--[Writer] float interger alias\nBufferComponent.writeF16 = BufferComponent.WriteF16\nBufferComponent.writef16 = BufferComponent.WriteF16\n\nBufferComponent.writeF32 = BufferComponent.WriteF32\nBufferComponent.writef32 = BufferComponent.WriteF32\n\nBufferComponent.writeF64 = BufferComponent.WriteF64\nBufferComponent.writef64 = BufferComponent.WriteF64\n\n--[Writer] string alias\nBufferComponent.writeString8 = BufferComponent.WriteString8\nBufferComponent.writestring8 = BufferComponent.WriteString8\n\nBufferComponent.writeString16 = BufferComponent.WriteString16\nBufferComponent.writestring16 = BufferComponent.WriteString16\n\nBufferComponent.writeString32 = BufferComponent.WriteString32\nBufferComponent.writestring32 = BufferComponent.WriteString32\n\nBufferComponent.writeString64 = BufferComponent.WriteString64\nBufferComponent.writestring64 = BufferComponent.WriteString64\n\nBufferComponent.writeString = BufferComponent.WriteString\nBufferComponent.writestring = BufferComponent.WriteString\n\n--[Writer] boolean alias\nBufferComponent.writeBool1 = BufferComponent.WriteBool1\nBufferComponent.writebool1 = BufferComponent.WriteBool1\n\nBufferComponent.writeBool8 = BufferComponent.WriteBool8\nBufferComponent.writebool8 = BufferComponent.WriteBool8\n\n\n--[Writer] instance alias\nBufferComponent.writeInstance = BufferComponent.WriteInstance\nBufferComponent.writeinstance = BufferComponent.WriteInstance\n\n--[Writer] roblox type alias\nBufferComponent.writeVector2 = BufferComponent.WriteVector2\nBufferComponent.writevector2 = BufferComponent.WriteVector2\n\nBufferComponent.writeVector2int16 = BufferComponent.WriteVector2Int16\nBufferComponent.writevector2int16 = BufferComponent.WriteVector2Int16\n\nBufferComponent.writeVector3 = BufferComponent.WriteVector3\nBufferComponent.writevector3 = BufferComponent.WriteVector3\n\nBufferComponent.writeVector3int16 = BufferComponent.WriteVector3Int16\nBufferComponent.writevector3int16 = BufferComponent.WriteVector3Int16\n\nBufferComponent.writeCFrame = BufferComponent.WriteCFrame\nBufferComponent.writecframe = BufferComponent.WriteCFrame\n\nBufferComponent.writeLossyCFrame = BufferComponent.WriteLossyCFrame\nBufferComponent.writelossyCFrame = BufferComponent.WriteLossyCFrame\n\nBufferComponent.writeUdim = BufferComponent.WriteUDim\nBufferComponent.writeudim = BufferComponent.WriteUDim\nBufferComponent.WriteUdim = BufferComponent.WriteUDim\n\nBufferComponent.writeUdim2 = BufferComponent.WriteUDim2\nBufferComponent.writeudim2 = BufferComponent.WriteUDim2\nBufferComponent.WriteUdim2 = BufferComponent.WriteUDim2\n\nBufferComponent.writeColor3 = BufferComponent.WriteColor3\nBufferComponent.writecolor3 = BufferComponent.WriteColor3\n\nBufferComponent.writeRect = BufferComponent.WriteRect\nBufferComponent.writerect = BufferComponent.WriteRect\n\nBufferComponent.writeRegion3 = BufferComponent.WriteRegion3\nBufferComponent.writeregion3 = BufferComponent.WriteRegion3\n\nBufferComponent.WriteRegion3Int16 = BufferComponent.WriteRegion3int16\nBufferComponent.writeRegion3int16 = BufferComponent.WriteRegion3int16\nBufferComponent.writeregion3int16 = BufferComponent.WriteRegion3int16\n\nBufferComponent.writeVector = BufferComponent.WriteVector\nBufferComponent.writevector = BufferComponent.WriteVector\n\nBufferComponent.writeEnum = BufferComponent.WriteEnum\nBufferComponent.writeenum = BufferComponent.WriteEnum\n\nBufferComponent.writeRotationCurveKey = BufferComponent.WriteRotationCurveKey\n\nBufferComponent.writeFloatCurveKey = BufferComponent.WriteFloatCurveKey\n\nBufferComponent.writeColorSequence = BufferComponent.WriteColorSequence\n\nBufferComponent.writeNumberRange = BufferComponent.WriteNumberRange\n\nBufferComponent.writeNumberSequence = BufferComponent.WriteNumberSequence\n\n--[Custom Writer] alias\nBufferComponent.writeAs = BufferComponent.WriteAs\n\nBufferComponent.writeArray = BufferComponent.WriteArray\nBufferComponent.writearray = BufferComponent.WriteArray\n\n--[Reader] signed interger alias\nBufferComponent.readI1 = BufferComponent.ReadI1\nBufferComponent.readi1 = BufferComponent.ReadI1\n\nBufferComponent.readI8 = BufferComponent.ReadI8\nBufferComponent.readi8 = BufferComponent.ReadI8\n\nBufferComponent.readI16 = BufferComponent.ReadI16\nBufferComponent.readi16 = BufferComponent.ReadI16\n\nBufferComponent.readI24 = BufferComponent.ReadI24\nBufferComponent.readi24 = BufferComponent.ReadI24\n\nBufferComponent.readI32 = BufferComponent.ReadI32\nBufferComponent.readi32 = BufferComponent.ReadI32\n\nBufferComponent.readI40 = BufferComponent.ReadI40\nBufferComponent.readi40 = BufferComponent.ReadI40\n\nBufferComponent.readI48 = BufferComponent.ReadI48\nBufferComponent.readi48 = BufferComponent.ReadI48\n\nBufferComponent.readI54 = BufferComponent.ReadI54\nBufferComponent.readi54 = BufferComponent.ReadI54\n\n--[Reader] unsigned interger alias\nBufferComponent.readU1 = BufferComponent.ReadU1\nBufferComponent.readu1 = BufferComponent.ReadU1\n\nBufferComponent.readU8 = BufferComponent.ReadU8\nBufferComponent.readu8 = BufferComponent.ReadU8\n\nBufferComponent.readU16 = BufferComponent.ReadU16\nBufferComponent.readu16 = BufferComponent.ReadU16\n\nBufferComponent.readU24 = BufferComponent.ReadU24\nBufferComponent.readu24 = BufferComponent.ReadU24\n\nBufferComponent.readU32 = BufferComponent.ReadU32\nBufferComponent.readu32 = BufferComponent.ReadU32\n\nBufferComponent.readU40 = BufferComponent.ReadU40\nBufferComponent.readu40 = BufferComponent.ReadU40\n\nBufferComponent.readU48 = BufferComponent.ReadU48\nBufferComponent.readu48 = BufferComponent.ReadU48\n\nBufferComponent.readU54 = BufferComponent.ReadU54\nBufferComponent.readu54 = BufferComponent.ReadU54\n\n--[Reader] float interger alias\nBufferComponent.readF16 = BufferComponent.ReadF16\nBufferComponent.readf16 = BufferComponent.ReadF16\n\nBufferComponent.readF32 = BufferComponent.ReadF32\nBufferComponent.readf32 = BufferComponent.ReadF32\n\nBufferComponent.readF64 = BufferComponent.ReadF64\nBufferComponent.readf64 = BufferComponent.ReadF64\n\n--[Reader] boolean alias\nBufferComponent.readBool1 = BufferComponent.ReadBool1\nBufferComponent.readbool1 = BufferComponent.ReadBool1\n\nBufferComponent.readBool8 = BufferComponent.ReadBool8\nBufferComponent.readbool8 = BufferComponent.ReadBool8\n\n\n--[Reader] string alias\nBufferComponent.readString = BufferComponent.ReadString\nBufferComponent.readstring = BufferComponent.ReadString\n\n--[Reader] instance alias\nBufferComponent.readInstance = BufferComponent.ReadInstance\nBufferComponent.readinstance = BufferComponent.ReadInstance\n\n--[Reader] roblox type alias\nBufferComponent.readVector2 = BufferComponent.ReadVector2\nBufferComponent.readvector2 = BufferComponent.ReadVector2\n\nBufferComponent.ReadVector2Int16 = BufferComponent.ReadVector2int16\nBufferComponent.readVector2int16 = BufferComponent.ReadVector2int16\nBufferComponent.readvector2int16 = BufferComponent.ReadVector2int16\n\nBufferComponent.readVector3 = BufferComponent.ReadVector3\nBufferComponent.readvector3 = BufferComponent.ReadVector3\n\nBufferComponent.readVector3int16 = BufferComponent.ReadVector3int16\nBufferComponent.readvector3int16 = BufferComponent.ReadVector3int16\nBufferComponent.ReadVector3Int16 = BufferComponent.ReadVector3int16\n\nBufferComponent.readCFrame = BufferComponent.ReadCFrame\nBufferComponent.readcframe = BufferComponent.ReadCFrame\n\nBufferComponent.readLossyCFrame = BufferComponent.ReadLossyCFrame\nBufferComponent.readlossyCFrame = BufferComponent.ReadLossyCFrame\n\nBufferComponent.readUdim = BufferComponent.ReadUDim\nBufferComponent.readudim = BufferComponent.ReadUDim\nBufferComponent.ReadUdim = BufferComponent.ReadUDim\n\nBufferComponent.readUdim2 = BufferComponent.ReadUDim2\nBufferComponent.readudim2 = BufferComponent.ReadUDim2\nBufferComponent.ReadUdim2 = BufferComponent.ReadUDim2\n\nBufferComponent.readColor3 = BufferComponent.ReadColor3\nBufferComponent.readcolor3 = BufferComponent.ReadColor3\n\nBufferComponent.readRect = BufferComponent.ReadRect\nBufferComponent.readrect = BufferComponent.ReadRect\n\nBufferComponent.readRegion3 = BufferComponent.ReadRegion3\nBufferComponent.readregion3 = BufferComponent.ReadRegion3\n\nBufferComponent.ReadRegion3Int16 = BufferComponent.ReadRegion3int16\nBufferComponent.readRegion3int16 = BufferComponent.ReadRegion3int16\nBufferComponent.readregion3int16 = BufferComponent.ReadRegion3int16\n\nBufferComponent.readVector = BufferComponent.ReadVector\nBufferComponent.readvector = BufferComponent.ReadVector\n\nBufferComponent.readEnum = BufferComponent.ReadEnum\nBufferComponent.readenum = BufferComponent.ReadEnum\n\nBufferComponent.readRotationCurveKey = BufferComponent.ReadRotationCurveKey\n\nBufferComponent.readFloatCurveKey = BufferComponent.ReadFloatCurveKey\n\nBufferComponent.readColorSequence = BufferComponent.ReadColorSequence\n\nBufferComponent.readNumberRange = BufferComponent.ReadNumberRange\n\nBufferComponent.readNumberSequence = BufferComponent.ReadNumberSequence\n\n--[Custom Read] alias\nBufferComponent.readAs = BufferComponent.ReadAs\n\nBufferComponent.readArray = BufferComponent.ReadArray\nBufferComponent.readarray = BufferComponent.ReadArray\n\n--[Signals] alias\nBufferComponent.onOffsetChanged = BufferComponent.OnOffsetChanged\nBufferComponent.onCapacityChanged = BufferComponent.OnCapacityChanged\nBufferComponent.onInstanceOffsetChanged = BufferComponent.OnInstanceOffsetChanged\nBufferComponent.disconnectAllSignals = BufferComponent.DisconnectAllSignals\n\n--[Cursor] alias\nBufferComponent.getOffset = BufferComponent.GetOffset\nBufferComponent.getoffset = BufferComponent.GetOffset\n\nBufferComponent.getInstanceOffset = BufferComponent.GetInstanceOffset\nBufferComponent.getinstanceoffset = BufferComponent.GetInstanceOffset\n\nBufferComponent.getRemainingSpace = BufferComponent.GetRemainingSpace\n\n--[Buffer] alias\nBufferComponent.compress = BufferComponent.Compress\n\nBufferComponent.getBuffer = BufferComponent.GetBuffer\nBufferComponent.getbuffer = BufferComponent.GetBuffer\n\nBufferComponent.getInstanceBuffer = BufferComponent.GetInstanceBuffer\nBufferComponent.getinstancebuffer = BufferComponent.GetInstanceBuffer\n\nBufferComponent.getBufferSize = BufferComponent.GetBufferSize\nBufferComponent.getbuffersize = BufferComponent.GetBufferSize\n\nBufferComponent.Copy = BufferComponent.copy\n\n--[Lifecycle] alias\nBufferComponent.Clear = BufferComponent.clear\n\nBufferComponent.ClearInstances = BufferComponent.clearInstances\n\nBufferComponent.ClearBuffer = BufferComponent.clearBuffer\n\nBufferComponent.Destroy = BufferComponent.Destroy\n</code></pre>"},{"location":"API/Buffer/Reading/","title":"Reading","text":""},{"location":"API/Buffer/Reading/#reading-signed-int","title":"Reading Signed-int","text":"<p>To read signed numbers, the methods to use will be <code>:ReadI</code>, etc.</p>"},{"location":"API/Buffer/Reading/#reading-i1","title":"Reading I1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteI1(1)\n\nprint(myBuffer:ReadI1(0)) -&gt; this will return 1\n</code></pre> <p>Read a Signed 1-bit integer from the buffer.</p> <p>Range: -1 - 1</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-i8","title":"Reading I8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteI8(127)\n\nprint(myBuffer:ReadI8(0)) --&gt; this will return 127\n</code></pre> <p>Read a Signed 8-bit integer from the buffer (byte-aligned).</p> <p>Returns number in [-128, 127] or nil on failure.</p>"},{"location":"API/Buffer/Reading/#reading-i16","title":"Reading I16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\n\nmyBuffer:WriteI16(32_767)\n\nprint(myBuffer:ReadI16(0)) --&gt; this will return 32,767\n</code></pre> <p>Read a Signed 16-bit integer from the buffer (byte-aligned).</p> <p>Returns number in [-32768, 32767] or nil on failure.</p>"},{"location":"API/Buffer/Reading/#reading-i24","title":"Reading I24","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(3)\n\nmyBuffer:WriteI24(8_388_607)\n\nprint(myBuffer:ReadI24(0)) --&gt; this will return 8,388,607\n</code></pre> <p>Read a Signed 24-bit integer (big-endian) from the buffer.</p> <p>Returns:</p> <ul> <li>number in [-2^23, 2^23-1] on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-i32","title":"Reading I32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteI32(2_147_483_647)\n\nprint(myBuffer:ReadI32(0)) --&gt; this will return 2,147,483,647\n</code></pre> <p>Read a Signed 32-bit integer from the buffer.</p> <p>Returns number in [-2^31, 2^31-1] or nil on failure.</p>"},{"location":"API/Buffer/Reading/#reading-i40","title":"Reading I40","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(5)\n\nmyBuffer:WriteI40(549_755_813_887)\n\nprint(myBuffer:ReadI40(0)) --&gt; this will return 549,755,813,887\n</code></pre> <p>Read a Signed 40-bit integer (big-endian) from the buffer.</p> <p>Range: - -2^39 .. 2^39-1</p> <p>Returns:</p> <ul> <li>number on success (exactly representable in double for 40-bit)</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-i48","title":"Reading I48","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(6)\n\nmyBuffer:WriteI48(140_737_488_355_327)\n\nprint(myBuffer:ReadI48(0)) --&gt; this will return 140,737,488,355,327\n</code></pre> <p>Read a Signed 48-bit integer (big-endian) from the buffer.</p> <p>Range: -2^47 .. 2^47-1  (i.e., -140,737,488,355,328 .. 140,737,488,355,327)</p> <p>Returns:</p> <ul> <li>number on success (exactly representable in double for 48-bit)</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-i54","title":"Reading I54","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(7)\n\nmyBuffer:WriteI54(9_007_199_254_740_991)\n\nprint(myBuffer:ReadI54(0)) --&gt; this will return 9,007,199,254,740,991\n</code></pre> <p>Read a Signed 54-bit integer (big-endian) from the buffer.</p> <p>Range: -2^53 .. 2^53-1</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-unsigned-int","title":"Reading Unsigned-int","text":"<p>To read unsigned numbers, the methods to use will be <code>:ReadU</code>, etc.</p>"},{"location":"API/Buffer/Reading/#reading-u1","title":"Reading U1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteU1(1)\n\nprint(myBuffer:ReadU1(0)) --&gt; this will return 1\n</code></pre> <p>Read 1 unsigned bit from the buffer.</p> <p>Returns: - 0 or 1 on success - nil on failure (warns)</p>"},{"location":"API/Buffer/Reading/#reading-u8","title":"Reading U8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteU8(255)\n\nprint(myBuffer:ReadU8(0)) --&gt; this will return 255\n</code></pre> <p>Read an Unsigned 8-bit integer (byte) from the buffer.</p> <p>Returns number in [0, 255] or nil on failure.</p>"},{"location":"API/Buffer/Reading/#reading-u16","title":"Reading U16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\n\nmyBuffer:WriteU16(65_535)\n\nprint(myBuffer:ReadU16(0)) --&gt; this will return 65,535\n</code></pre> <p>Read an Unsigned 16-bit integer (big-endian) from the buffer.</p> <p>Returns number in [0, 65535] or nil on failure.</p>"},{"location":"API/Buffer/Reading/#reading-u24","title":"Reading U24","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(3)\n\nmyBuffer:WriteU24(16_777_215)\n\nprint(myBuffer:ReadU24(0)) --&gt; this will return 16,777,215\n</code></pre> <p>Read an Unsigned 24-bit integer (big-endian) from the buffer.</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-u32","title":"Reading U32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteU32(4_294_967_295)\n\nprint(myBuffer:ReadU32(0)) --&gt; this will return 4,294,967,295\n</code></pre> <p>Read an Unsigned 32-bit integer from the buffer.</p> <p>Returns number in [0, 2^32-1]</p>"},{"location":"API/Buffer/Reading/#reading-u40","title":"Reading U40","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(5)\n\nmyBuffer:WriteU40(1_099_511_627_775)\n\nprint(myBuffer:ReadU40(0)) --&gt; this will return 1,099,511,627,775\n</code></pre> <p>Read an Unsigned 40-bit integer (big-endian) from the buffer.</p> <p>Returns:</p> <ul> <li>number on success (exact for 40-bit in double)</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-u48","title":"Reading U48","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(6)\n\nmyBuffer:WriteU48(281_474_976_710_655)\n\nprint(myBuffer:ReadU48(0)) --&gt; this will return 281,474,976,710,655\n</code></pre> <p>Read an Unsigned 48-bit integer from the buffer (6 bytes, big-endian by default).</p> <p>Returns:</p> <ul> <li>number in [0, 2^48 - 1] on success (exactly representable in double)</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-u54","title":"Reading U54","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(7)\n\nmyBuffer:WriteU54(18_014_398_509_481_980)\n\nprint(myBuffer:ReadU54(0)) --&gt; this will return 18,014,398,509,481,980\n</code></pre> <p>Read an Unsigned 54-bit integer from the buffer.</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-float","title":"Reading Float","text":"<p>For floats, methods like <code>:ReadF</code> will be used.</p>"},{"location":"API/Buffer/Reading/#reading-f16","title":"Reading F16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\n\nmyBuffer:WriteF16(2.454)\n\nprint(myBuffer:ReadF16(0)) --&gt; this will return 2.453125\n</code></pre> <p>Read a 16-bit half-precision float (IEEE 754 binary16) from the buffer.</p> <p>Encoding:</p> <ul> <li>1 sign bit, 5 exponent bits (bias 15), 10 mantissa bits.</li> </ul> <p>Returns:</p> <ul> <li>number on success (double-precision representation of the half)</li> <li>nil on failure (warns)</li> </ul> <p>Notes on special cases:</p> <ul> <li>Exponent == 0 and mantissa == 0 =&gt; +/- 0</li> <li>Exponent == 0 and mantissa != 0 =&gt; denormalized number</li> <li>Exponent == 31 (all ones):<ul> <li>mantissa == 0 =&gt; +/- infinity</li> <li>mantissa != 0 =&gt; NaN</li> </ul> </li> </ul>"},{"location":"API/Buffer/Reading/#reading-f32","title":"Reading F32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteF32(2.454)\n\nprint(myBuffer:ReadF32(0)) --&gt; this will return 2.4539999961853027\n</code></pre> <p>Read a Float32 from the buffer at the given offset (or self.offset if not provided/valid).</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-f64","title":"Reading F64","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\n\nmyBuffer:WriteF64(2.454)\n\nprint(myBuffer:ReadF64(0)) --&gt; this will return 2.454\n</code></pre> <p>Read a Float64 from the buffer at the given offset (or self.offset if not provided/valid).</p> <p>Returns:</p> <ul> <li>number on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-strings","title":"Reading Strings","text":"<p>For strings, only one method is available: <code>:ReadString</code>.</p>"},{"location":"API/Buffer/Reading/#reading-string","title":"Reading String","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(11)\n\nmyBuffer:WriteString(\"Hello World\")\n\n--                       len|offset  \nprint(myBuffer:ReadString(11,0)) --&gt; this will return Hello World\n</code></pre> <p>Read a String from the buffer.</p> <p>Parameters:</p> <ul> <li>len: number of bytes to read. If omitted, defaults to Constants.MIN_STRING.</li> <li>offset (optional): byte offset to read from. If omitted/invalid, falls back to self.offset.</li> </ul> <p>Returns:</p> <ul> <li>string on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-roblox-types","title":"Reading Roblox Types","text":"<p>For reading Roblox types, the methods to use are <code>:Read[TypeName]</code>.</p>"},{"location":"API/Buffer/Reading/#reading-bool1","title":"Reading Bool1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteBool1(true)\n\nprint(myBuffer:ReadBool1(0)) --&gt; this will return true\n</code></pre> <p>Read a 1-bit boolean from the buffer at a given bit offset.</p> <p>Returns:</p> <ul> <li>boolean on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-bool8","title":"Reading Bool8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nlocal arrayOfValues = {\n    true,\n    true,\n    false,\n    nil,\n    1,\n    true,\n    \"hello world\",\n    false\n} \n\nmyBuffer:WriteBool8(arrayOfValues)\n\nprint(myBuffer:ReadBool8(0))\n--[[\n      {\n        value = {bool, bool, ..., bool}, -- the 8 bits in order\n        majority = function(): boolean   -- true if more trues than falses\n      }\n]]\n</code></pre> <p>Read 8 booleans (1 bit each) starting at a given bit offset.</p> <p>Returns:</p> <p>A table: {</p> <p>value = {bool, bool, ..., bool}, -- the 8 bits in order</p> <p>majority = function(): boolean   -- true if more trues than falses</p> <p>}</p>"},{"location":"API/Buffer/Reading/#reading-instance","title":"Reading Instance","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0)\n\nmyBuffer:WriteInstance(workspace.Baseplate)\n\nprint(myBuffer:ReadInstance(1)) -- MUST BEGIN AT 1 NOT 0\n</code></pre> <p>Read an Instance from self.instance_buffer at the given index (or self.instance_offset).</p> <p>Returns:</p> <ul> <li>Instance or nil</li> </ul>"},{"location":"API/Buffer/Reading/#reading-vector2","title":"Reading Vector2","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(16)\n\nmyBuffer:WriteVector2(Vector2.new(10,10))\n\nprint(myBuffer:ReadVector2(0)) --&gt; this will return Vector2.new(10,10)\n</code></pre> <p>Read a Vector2 (double-precision) from the buffer</p> <p>Returns:</p> <ul> <li>Vector2 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-vector3","title":"Reading Vector3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(24)\n\nmyBuffer:WriteVector3(Vector3.new(10,10,5))\n\nprint(myBuffer:ReadVector3(0)) --&gt; this will return Vector3.new(10,10,5)\n</code></pre> <p>Read a Vector3 (double-precision) from the buffer</p> <p>Returns:</p> <ul> <li>Vector3 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-vector2int16","title":"Reading Vector2Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteVector2Int16(Vector2int16.new(10,10))\n\nprint(myBuffer:ReadVector2int16(0)) --&gt; this will return Vector2int16.new(10,10)\n</code></pre> <p>Read a Vector2int16 from the buffer</p> <p>Returns:</p> <ul> <li>Vector2int16 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-vector3int16","title":"Reading Vector3Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(6)\n\nmyBuffer:WriteVector3Int16(Vector3int16.new(10,10,10))\n\nprint(myBuffer:ReadVector3int16(0)) --&gt; this will return Vector3int16.new(10,10)\n</code></pre> <p>Read a Vector3int16 from the buffer</p> <p>Returns:</p> <ul> <li>Vector3int16 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-cframe","title":"Reading CFrame","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(96)\n\nmyBuffer:WriteCFrame(workspace.Baseplate.CFrame)\n\nprint(myBuffer:ReadCFrame(0)) --&gt; return the cframe of the baseplate\n</code></pre> <p>Read a CFrame (double-precision) from the buffer</p> <ul> <li>Constructs CFrame.new(...) from these 12 components.</li> </ul> <p>Returns:</p> <ul> <li>CFrame on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-lossycframe","title":"Reading LossyCFrame","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(48)\n\nmyBuffer:WriteLossyCFrame(workspace.Baseplate.CFrame)\n\nprint(myBuffer:ReadLossyCFrame(0)) --&gt; return the lossy cframe of the baseplate\n</code></pre> <p>Read a \"Lossy\" CFrame (single-precision) from the buffer</p> <ul> <li>Lower precision than ReadCFrame; saves space.</li> </ul> <p>Returns:</p> <ul> <li>CFrame on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-udim","title":"Reading UDim","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\n\nlocal CornerRadius = YourGui.UICorner.CornerRadius -- This is a UDim\n\nmyBuffer:WriteUDim(CornerRadius)\n\nprint(myBuffer:ReadUDim(0)) --&gt; return your UDim\n</code></pre> <p>Read a UDim from the buffer</p> <p>Returns:</p> <ul> <li>UDim on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-udim2","title":"Reading UDim2","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(16)\n\nlocal pos = YourGui.Position -- This is a UDim2\n\nmyBuffer:WriteUDim2(pos)\n\nprint(myBuffer:ReadUDim(0)) --&gt; return your position\n</code></pre> <p>Read a UDim2 from the buffer:</p> <ul> <li>Returns UDim2.new(scaleX, offsetX, scaleY, offsetY)</li> </ul> <p>Returns:</p> <ul> <li>UDim2 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-color3","title":"Reading Color3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(12)\n\nlocal color = Color3.new(1,1,1)\n\nmyBuffer:WriteColor3(color)\n\nprint(myBuffer:ReadColor3(0)) --&gt; return the color3\n</code></pre> <p>Read a Color3 from the buffer:</p> <p>Returns:</p> <ul> <li>Color3 on success</li> <li>nil on failure (warns)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-rect","title":"Reading Rect","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(32)\n\nlocal rect1 = Rect.new(Vector2.new(10, 10), Vector2.new(80, 80))\n\nmyBuffer:WriteRect(rect1)\n\nprint(myBuffer:ReadRect(0)) --&gt; return the rect\n</code></pre> <p>Read a Rect from the buffer:</p> <ul> <li>Two Vector2 (double-precision) values back-to-back: typically min then max (or vice versa).</li> <li>This implementation reads:   max = ReadVector2(offset)   min = ReadVector2(offset + 16)   and returns Rect.new(min, max).</li> </ul> <p>Returns:</p> <ul> <li>Rect on success</li> <li>nil on failure (if nested reads fail)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-region3","title":"Reading Region3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(120)\n\nlocal region = Region3.new(\n    Vector3.new(0, 0, 0),\n    Vector3.new(20, 20, 20)\n)\n\nmyBuffer:WriteRegion3(region)\n\nprint(myBuffer:ReadRegion3(0)) --&gt; return the region3\n</code></pre> <p>Read a Region3 from the buffer</p> <p>Returns:</p> <ul> <li>Region3 on success</li> <li>nil on failure (if nested reads fail)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-region3int16","title":"Reading Region3Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(12)\n\nlocal region = Region3int16.new(\n    Vector3int16.new(0, 0, 0),\n    Vector3int16.new(50, 100, 50)\n)\n\nmyBuffer:WriteRegion3int16(region)\n\nprint(myBuffer:ReadRegion3int16(0)) --&gt; return the region3int16\n</code></pre> <p>Read a Region3int16 from the buffer</p> <p>Returns:</p> <ul> <li>Region3int16 on success</li> <li>nil on failure (if nested reads fail)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-vector-luau-library","title":"Reading vector (luau library)","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(24)\n\nlocal vect = vector.create(10,1,1)\n\nmyBuffer:WriteVector(vect)\n\nprint(myBuffer:ReadVector(0)) --&gt; return the `vector`\n</code></pre> <p>Read a 'vector' from the luau library at the given offset</p> <p>Returns:</p> <ul> <li>vector on success</li> <li>nil on failure (if nested reads fail)</li> </ul>"},{"location":"API/Buffer/Reading/#reading-enum","title":"Reading Enum","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteEnum(Enum.KeyCode.A)\n\nprint(myBuffer:ReadEnum(0)) --&gt; return the actual enum (e.g Enum.KeyCode.A)\n</code></pre> <p>Reads an EnumItem from the buffer that was previously written with WriteEnum.</p> <p>Returns: </p> <ul> <li>EnumItem </li> <li>nil</li> </ul> <p>The deserialized EnumItem, or nil if read fails</p>"},{"location":"API/Buffer/Reading/#reading-rotationcurvekey","title":"Reading RotationCurveKey","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\nlocal key = myBuffer:ReadRotationCurveKey() -- Read from current position\nlocal key2 = myBuffer:ReadRotationCurveKey(256) -- Read from specific offset\n\nif key.Interpolation == Enum.KeyInterpolationMode.Cubic then\n    print(key.LeftTangent, key.RightTangent) -- Will have tangent values\nend\n</code></pre> <p>Reads a RotationCurveKey from the buffer that was previously written with <code>WriteRotationCurveKey</code>.</p> <p>Info</p> <ul> <li>Automatically handles variable size based on interpolation mode</li> <li>Cubic keys will have their tangent properties set after creation</li> </ul>"},{"location":"API/Buffer/Reading/#reading-floatcurvekey","title":"Reading FloatCurveKey","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\nlocal key = myBuffer:ReadFloatCurveKey() -- Read from current position\nlocal key2 = myBuffer:ReadFloatCurveKey(128) -- Read from specific offset\n\nprint(key.Time, key.Value) -- Basic properties always present\nif key.Interpolation == Enum.KeyInterpolationMode.Cubic then\n    print(key.LeftTangent, key.RightTangent) -- Tangent values for Cubic\nend\n</code></pre> <p>Reads a FloatCurveKey from the buffer that was previously written with <code>WriteFloatCurveKey</code>.</p> <p>Info</p> <ul> <li>Value is read as F64 to preserve animation curve precision</li> <li>Automatically detects and handles Cubic interpolation tangents</li> </ul>"},{"location":"API/Buffer/Reading/#reading-colorsequence","title":"Reading ColorSequence","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\nlocal seq = myBuffer:ReadColorSequence()         -- from current offset\nlocal seq2 = myBuffer:ReadColorSequence(256)    -- from a specific offset\n</code></pre> <p>Reads a ColorSequence from the buffer that was previously written with <code>WriteColorSequence</code>.</p> <p>Warning</p> <ul> <li>Maximum 255 keypoints due to U8 count storage.</li> </ul>"},{"location":"API/Buffer/Reading/#reading-numberrange","title":"Reading NumberRange","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\nlocal range = Buffer:ReadNumberRange()       -- from current offset\nlocal range2 = Buffer:ReadNumberRange(256)   -- from a specific offset\n</code></pre> <p>Reads a NumberRange from the buffer that was previously written with <code>WriteNumberRange</code>.</p>"},{"location":"API/Buffer/Reading/#reading-numbersequence","title":"Reading NumberSequence","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\nlocal seq = Buffer:ReadNumberSequence()        -- from current offset\nlocal seq2 = Buffer:ReadNumberSequence(256)   -- from a specific offset\n</code></pre> <p>Reads a NumberSequence from the buffer that was previously written with <code>WriteNumberSequence</code>.</p> <p>Warning</p> <ul> <li>Maximum of 255 keypoints due to U8 count storage.</li> </ul>"},{"location":"API/Buffer/Reading/#custom-reading","title":"Custom Reading","text":""},{"location":"API/Buffer/Reading/#readas","title":"ReadAs","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1024) -- ~1kb\n\n--[[\n  For all string type the `OptionalParam` must be the length\n  otherwise it will use the a defined length for [String8 = 8 len, etc..] or it will thrown an error\n]]\nlocal name = myBuffer:ReadAs(\"String\",{Offset = 0,OptionalParam = 15})\n</code></pre> <p>Read any target type from the buffer</p> <p>Dynamically routes to appropriate Read function based on valueType</p> <p>Params : </p> <ul> <li>@param valueType: ValueType - Type of value to read</li> <li>@param param: optional_param - Optional parameters (Offset, OptionalParam for string length)</li> </ul>"},{"location":"API/Buffer/Reading/#readarray","title":"ReadArray","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\n\nlocal my_buffer = Buffer.create(145)\n\nlocal schema = {\n    {Type =  \"String\",Length = 8},\n    \"RotationCurveKey\",\n    \"ColorSequence\"\n}\n\nlocal value = {\n    \"Hello World !!\", -- will be \"Hello Wo\" (limit to 8 characters)\n    RotationCurveKey.new(0,workspace.Baseplate.CFrame,Enum.KeyInterpolationMode.Linear),\n    ColorSequence.new({\n        ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),\n        ColorSequenceKeypoint.new(1,Color3.new(1,1,1)),\n    })\n}\n\nmy_buffer:WriteArray(schema,value)\n\nprint(my_buffer:ReadArray(schema,0))  --&gt; return expected array\n</code></pre> <p>Reads an array of typed values from the buffer.</p> <p>Reads each value according to its specified type and returns them in order.</p> <ul> <li>@param array {ValueType} - Array of value types to read (e.g., \"UInt8\", \"String16\")</li> <li>@param offset number? - Optional starting offset (defaults to current offset)</li> <li>@return {any} - Array of read values in the same order as input types</li> </ul> <p>Info</p> <p>See WriteArray for more informations.</p>"},{"location":"API/Buffer/Serialization/","title":"Serialization","text":""},{"location":"API/Buffer/Serialization/#getting-started","title":"Getting Started","text":"<p>To serialize a BufferComponent, you simply need to assign a Schema and the table containing the values.</p> <p>Note</p> <p>Each index must exactly match the name in the Schema. e.g: Schema = {Hello = \"String8\"}, Values = {Hello = \"World\"} Otherwise the value will be skipped and may cause errors.</p> <p>Warning</p> <p>You can serialize/deserialize an Instance, but it will use a table not a buffer.</p> <p>Find more here : Advanced , Writing or Reading </p>"},{"location":"API/Buffer/Serialization/#methods","title":"Methods","text":""},{"location":"API/Buffer/Serialization/#serialize","title":"Serialize","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\n--[[\n    Here we define a schema for buffer serialization/deserialization\n    The schema specifies the structure and data types of the buffer\n]]\nlocal Schema : Buffer.BufferSchema = {\n    Hello = \"String16\"\n}\n\n--FOR NON DEFINED STRING LENGTH\n--[[\n    local Schema : Buffer.BufferSchema = {\n        Hello = {\n            Type = \"String\",\n            Length = 13\n        }\n    }\n    this only work for strings.\n    For other types you have to use the normal way of defining the schema.\n]]\n\nlocal Value = {\n    Hello = \"Hello World !\" --&gt; 13 chars so 3 padding character will be added\n}\n\nlocal serialized = Buffer.Serialize(Schema,Value)\nprint(serialized) --&gt; will print BufferComponent(Size:16)\n\n--[[\n    Note:\n    You will be able to use any method inside the BufferComponent but this is at your own risk i recommend to let\n    the serialized buffer like that and only use it when you really know what you are doing\n]]\n</code></pre> <p>Serializes the given Values according to the Schema into a BufferComponentClass</p>"},{"location":"API/Buffer/Serialization/#deserialize","title":"Deserialize","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal Schema : Buffer.BufferSchema = {\n    Hello = \"String16\"\n}\n\nlocal Value = {\n    Hello = \"Hello World !\" \n}\n\nlocal serialized = Buffer.Serialize(Schema,Value)\n\n--Deserializing the buffer\n\n--the schema need to be same as the one used to serialize\n\nlocal deserialized = Buffer.Deserialize(Schema,serialized)\nprint(deserialized) -- will print { Hello = \"Hello World !\" }\n</code></pre> <p>Deserializes a BufferComponentClass into a table of values according to Schema</p>"},{"location":"API/Buffer/Serialization/#serializeall","title":"SerializeAll","text":"<p>Same as Serialize but accepts a table of values and a table of schemas.</p> <p>Each schema will be serialized with its corresponding value.</p> <p>Note</p> <p>This return a numeric table with BufferComponentClass as values in order.</p> <pre><code>local SchemaA : Buffer.BufferSchema = {\n    Name = {\n        Type = \"String\",\n        Length = 14,\n    }\n}\n\nlocal SchemaB : Buffer.BufferSchema = {\n    Name = {\n        Type = \"String\",\n        Length = 20,\n    }\n}\n\nlocal A = {\n    Name = \"Hello World !!\",\n}\n\nlocal B = {\n    Name = \"Goodbye World !!\",\n}\n\n--The order is important !\nlocal buff = Buffer.SerializeAll({SchemaA,SchemaB},{A,B})\n</code></pre>"},{"location":"API/Buffer/Serialization/#deserializeall","title":"DeserializeAll","text":"<p>Same as Serialize but accepts a table of values and a table of schemas.</p> <p>Each schema will be serialized with its corresponding value.</p> <p>Note</p> <p>This return a numeric table with BufferComponentClass as values in order.</p> <pre><code>local SchemaA : Buffer.BufferSchema = {\n    Name = {\n        Type = \"String\",\n        Length = 14,\n    }\n}\n\nlocal SchemaB : Buffer.BufferSchema = {\n    Name = {\n        Type = \"String\",\n        Length = 20,\n    }\n}\n\nlocal A = {\n    Name = \"Hello World !!\",\n}\n\nlocal B = {\n    Name = \"Goodbye World !!\",\n}\n\n--The order is important for both methods !!!!!\nlocal buff = Buffer.SerializeAll({SchemaA,SchemaB},{A,B})\n\nprint(Buffer.DeserializeAll({SchemaA,SchemaB},buff))\n</code></pre>"},{"location":"API/Buffer/Serialization/#serializecompress","title":"SerializeCompress","text":"<pre><code>local Schema : Buffer.BufferSchema = {\n    Id = \"String64\",\n    Name = {\n        Type = \"String\",\n        Length = 15,\n    },\n    Position = \"Vector3\",\n    Health = \"U54\",\n    SkinColor = \"ColorSequence\",\n}\n\nlocal Values = {\n    Id = HttpService:GenerateGUID(false):sub(1,64),\n    Name = \"Name:\"..(HttpService:GenerateGUID(false):sub(1,10)),\n    Position = Vector3.new(15,250.95,150),\n    Health = 1500,\n    SkinColor = ColorSequence.new({\n        ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),\n        ColorSequenceKeypoint.new(1,Color3.new(1,1,1)),\n    })\n}\n\nlocal compressed_buffer = Buffer.SerializeCompress(Schema,Values)\nprint(compressed_buffer) --&gt; buffer IS NOT A BufferComponent\n</code></pre> <p>Serializes a set of values according to the provided schema and then compresses the resulting buffer.</p> <p>Parameters:</p> <ul> <li>Schema <code>BufferSchema</code></li> <li>Values <code>table&lt;string, T&gt;</code></li> </ul> <p>Returns: buffer</p> <ul> <li>A compressed buffer produced by first serializing the input</li> <li>values and then applying Zstd compression.</li> </ul> <p>Warning</p> <ul> <li>The returned buffer is not directly readable. Use     <code>DeserializeCompressed(...)</code></li> <li>Do not use this for buffers smaller than 30 bytes or in the 30\u201350 bytes range.</li> </ul>"},{"location":"API/Buffer/Serialization/#deserializecompress","title":"DeserializeCompress","text":"<pre><code>local Schema : Buffer.BufferSchema = {\n    Id = \"String64\",\n    Name = {\n        Type = \"String\",\n        Length = 15,\n    },\n    Position = \"Vector3\",\n    Health = \"U54\",\n    SkinColor = \"ColorSequence\",\n}\n\nlocal Values = {\n    Id = HttpService:GenerateGUID(false):sub(1,64),\n    Name = \"Name:\"..(HttpService:GenerateGUID(false):sub(1,10)),\n    Position = Vector3.new(15,250.95,150),\n    Health = 1500,\n    SkinColor = ColorSequence.new({\n        ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),\n        ColorSequenceKeypoint.new(1,Color3.new(1,1,1)),\n    })\n}\n\nlocal compressed_buffer = Buffer.SerializeCompress(Schema,Values)\nlocal decompressed_buffer = Buffer.DeserializeCompress(Schema,compressed_buffer)\nprint(decompressed_buffer) --&gt; correspond values\n</code></pre> <p>Decompresses a previously compressed buffer and then deserializes its content according to the provided schema.</p> <p>Parameters:</p> <ul> <li>Schema <code>BufferSchema</code></li> </ul> <p>The schema describing how data was originally structured and stored.</p> <ul> <li>compressedBuffer <code>buffer</code></li> </ul> <p>A buffer that was produced using SerializeCompressed(...) and compressed using Zstd.</p> <p>Returns: <code>table&lt;string, T&gt;</code></p> <p>A table of deserialized values mapped by field name.</p> <p>Warning</p> <ul> <li>The buffer must have been created with the same schema used here.</li> <li>If the schema does not match the original one, deserialization will fail     or produce invalid data.</li> <li>You must use a compressed buffer using <code>:Compress</code> with the same Compression Algorithm.</li> </ul>"},{"location":"API/Buffer/Serialization/#serializeallcompressed","title":"SerializeAllCompressed","text":"<pre><code>local compressed_buffers = Buffer.SerializeAllCompressed({schema_a,schema_b},{value_a,value_b})\nprint(compressed_buffers) -&gt; {buffer}\n</code></pre> <p>Serializes and compresses multiple value sets using corresponding schemas.</p> <p>Parameters:</p> <ul> <li>Schemas <code>{BufferSchema}</code></li> </ul> <p>An array of schemas. Each schema describes how its corresponding value set should be serialized.</p> <ul> <li>Values <code>{ table&lt;string, T&gt; }</code></li> </ul> <p>An array where each entry is a table of named values to be serialized. The index of each value set must match the index of its schema.</p> <p>Returns: <code>{ buffer }</code></p> <p>An array of compressed buffers, one for each (Schema, Values) pair.</p> <p>Info</p> <ul> <li>For each index i:<ul> <li>Serialize(Schemas[i], Values[i]) \u2192 <code>Buffer</code></li> <li>Compress(Buffer) \u2192 <code>CompressedBuffer</code></li> </ul> </li> <li>The resulting compressed buffer is appended to the output array.</li> </ul> <p>Note</p> <ul> <li>Schemas and Values must have the same length and aligned ordering.</li> <li>If any schema or value set is invalid, the function throws an error.</li> <li>This is the bulk equivalent of <code>SerializeCompressed(...).</code></li> </ul>"},{"location":"API/Buffer/Serialization/#deserializeallcompressed","title":"DeserializeAllCompressed","text":"<pre><code>local compressed_buffers = Buffer.SerializeAllCompressed({schema_a,schema_b},{value_a,value_b})\nlocal decompressed_buffers = Buffer.DeserializeAllCompressed({schema_a,schema_b},compressed_buffers)\n\nprint(compressed_buffers) -&gt; {buffer}\nprint(decompressed_buffers) -&gt; {value_a,value_b}\n</code></pre> <p>Decompresses and deserializes multiple compressed buffers using their corresponding schemas.</p> <p>Parameters:</p> <ul> <li>Schemas <code>({BufferSchema})</code></li> </ul> <p>An array of schemas. Each schema defines how its corresponding decompressed buffer should be interpreted and reconstructed.</p> <ul> <li>Buffers <code>({buffer})</code></li> </ul> <p>An array of compressed buffers produced by SerializeAllCompressed(...) or SerializeCompressed(...). The index of each buffer must match the index of its schema.</p> <p>Returns: <code>{ { [string] : T } }</code></p> <p>An array of deserialized value tables. Each entry corresponds to the decompressed and deserialized result of the matching schema and buffer pair.</p>"},{"location":"API/Buffer/Serialization/#serializable-types","title":"Serializable Types","text":"Type Bytes I1 1 I8 1 I16 2 I24 3 I32 4 I40 5 I48 6 I54 7 U1 1 U8 1 U16 2 U24 3 U32 4 U40 5 U48 6 U54 7 F16 2 F32 4 F64 8 Bool1 1 Bool8 1 String8 8 (8-character max) String16 16 (16-character max) String32 32 (32-character max) String64 64 (64-character max) String desired len (must use <code>{Type = \"String\",Length = number}</code>) String16 16 (16-character max) Color3 12 Vector2 16 Vector2int16 4 Vector3 24 Vector3int16 6 CFrame 96 LossyCFrame 48 Rect 32 Region3 120 Region3int16 12 UDim 8 UDim2 16 vector 24 Enum 4 NumberRange 8 FloatCurveKey 16 or 24 <code>(if you use KeyInterpolationMode.Cubic)</code> RotationCurveKey 104 or 112 <code>(if you use KeyInterpoliationMode.Cubic)</code> ColorSequence 1 + 16 * number of <code>ColorSequenceKeypoint</code> NumberSequence 1 + 12 * number of <code>NumberSequenceKeypoint</code>"},{"location":"API/Buffer/Utilities/Buffer.Constants/","title":"Buffer.Constants","text":""},{"location":"API/Buffer/Utilities/Buffer.Constants/#getting-started","title":"Getting Started","text":"<p>The <code>Constants</code> module in Buffer is used to know the minimum and maximum values of types, for example signed and unsigned numbers, as well as strings.</p> <p>Note</p> <p>This module is used in Buffer to reduce values if they exceed their expected value too much.</p> <p>The <code>REQUIRED_BYTES</code> table allows you to know which type takes how many bytes. For strings with an undefined length, the number of bytes will depend on their length.</p> <p>You can also find the module version in the table.</p>"},{"location":"API/Buffer/Utilities/Buffer.Enum/","title":"Buffer.Enum","text":""},{"location":"API/Buffer/Utilities/Buffer.Enum/#getting-started","title":"Getting Started","text":"<p><code>Buffer.Enum</code> is a utility inside Buffer that allows you to access every existing type that you can write.</p> <p>This allows you to directly enumerate all available types. Note that each type will have a <code>Value</code> (number in order) and <code>Name</code> which will be the type name. It works exactly like the Enum class itself.</p>"},{"location":"API/Buffer/Utilities/Buffer.Utils/","title":"Buffer.Utils","text":""},{"location":"API/Buffer/Utilities/Buffer.Utils/#getting-started","title":"Getting Started","text":"<p>The <code>Utils</code> component in Buffer serves to, for example, calculate the number of bytes required or directly convert a number of bytes to Kilobytes, Megabytes, or Gigabytes.</p>"},{"location":"API/Buffer/Utilities/Buffer.Utils/#methods","title":"Methods","text":""},{"location":"API/Buffer/Utilities/Buffer.Utils/#getting-the-required-bytes","title":"Getting the required bytes","text":"<p>To get the specific number of bytes, you will need a Schema and a table containing the values.</p> <p>Note</p> <p>This function is used in <code>Buffer.Serialize</code>. I recommend reading that page if you are lost.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal Utils = Buffer.Utils\n\n--[[\n    I really recommend to put : Buffer.BufferSchema for type checking, but it's optional.\n\n    For any other type exepct String you will just need to put for example :\n\n    {\n        MyMessage = \"String8\" --&gt; 8 is the max length of the string\n    }\n\n    but for non-defined length you will need to put something like this:\n\n    {\n        MyMessage = {\n            Type = \"String\",\n            Length = number\n        }\n    }\n\n    Please note that when you put a string padding characters (string.char(31)) will be added to fill the remaining spaces\n    but for example when you will call : Buffer.Deserialize(YourSchema,BufferComponent)\n\n    all added characters will be automaticly removed\n]]\nlocal Schema : Buffer.BufferSchema = {\n    MyMessage = {\n        Type = \"String\",\n        Length = 14,\n    }\n}\n\n--Simple values (type checking is optional)\nlocal Values : Buffer.BufferSchemaValue = {\n    MyMessage = \"Hello World\"\n}\n\nprint(Utils.GetRequiredBytes(Schema,Values)) --&gt; this will return 14\n</code></pre>"},{"location":"API/Buffer/Utilities/Buffer.Utils/#converting-bytes","title":"Converting bytes","text":"<p>To convert bytes to Kilobytes, etc., the <code>ConvertTo</code> function would be used.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal Utils = Buffer.Utils\n\n--This will convert the current bytes to Kilobytes\n\nprint(Utils.ConvertByte(\"Kilobytes\",1024)) --&gt; this will return 1\n\n--First argument is the convertion and second argument is the bytes\n-- Supported convertions: Kilobytes, Megabytes, Gigabytes\n</code></pre>"},{"location":"API/Buffer/Writing/","title":"Writing","text":""},{"location":"API/Buffer/Writing/#writing-signed-int","title":"Writing Signed-int","text":"<p>To write signed numbers, you will need to use methods like <code>:WriteI1</code>, etc.</p>"},{"location":"API/Buffer/Writing/#writing-i1","title":"Writing I1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\nlocal num = 1\n\nmyBuffer:WriteI1(num)\n</code></pre> <p>Write a signed 1-bit integer (-1 to 1). The value is clamped to the allowed range and truncated to an integer.</p>"},{"location":"API/Buffer/Writing/#writing-i8","title":"Writing I8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\nlocal num = 127\n\nmyBuffer:WriteI8(num)\n</code></pre> <p>Write a signed 8-bit integer (-128 to 127). Clamped and truncated to integer.</p>"},{"location":"API/Buffer/Writing/#writing-i16","title":"Writing I16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\nlocal num = 32_767\n\nmyBuffer:WriteI16(num)\n</code></pre> <p>Write a signed 16-bit integer (-32768 to 32767). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-i24","title":"Writing I24","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(3)\nlocal num = 8_388_607\n\nmyBuffer:WriteI24(num)\n</code></pre> <p>Write a signed 24-bit integer (-8,388,608 to 8,388,607). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-i32","title":"Writing I32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 2_147_483_647\n\nmyBuffer:WriteI32(num)\n</code></pre> <p>Write a signed 32-bit integer (-2,147,483,648 to 2,147,483,647). - Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-i40","title":"Writing I40","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(5)\nlocal num = 549_755_813_887\n\nmyBuffer:WriteI40(num)\n</code></pre> <p>Write a signed 40-bit integer (-549,755,813,888 to 549,755,813,887). Clamped and truncated.</p> <p>If negative, add 2^40 to represent as unsigned (two's complement style) before writing.</p>"},{"location":"API/Buffer/Writing/#writing-i48","title":"Writing I48","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(6)\nlocal num = 140_737_488_355_327\n\nmyBuffer:WriteI48(num)\n</code></pre> <p>Write a signed 48-bit integer (-140,737,488,355,328 to 140,737,488,355,327). Clamped and truncated.</p> <p>If negative, add 2^48 to represent as unsigned before writing.</p>"},{"location":"API/Buffer/Writing/#writing-i54","title":"Writing I54","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(7)\nlocal num = 9_007_199_254_740_991\n\nmyBuffer:WriteI54(num)\n</code></pre> <p>Write a signed 54-bit integer (-9,007,199,254,740,992 to 9,007,199,254,740,991). Clamped and truncated.</p> <p>If negative, add 2^54 to represent as unsigned before writing.</p>"},{"location":"API/Buffer/Writing/#writing-unsigned-int","title":"Writing Unsigned-int","text":"<p>For unsigned numbers, you will need to use methods like <code>:WriteU</code>, etc.</p>"},{"location":"API/Buffer/Writing/#writing-u1","title":"Writing U1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\nlocal num = 1\n\nmyBuffer:WriteU1(num)\n</code></pre> <p>Write a single unsigned bit (0 or 1). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u8","title":"Writing U8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\nlocal num = 255\n\nmyBuffer:WriteU8(num)\n</code></pre> <p>Write an unsigned 8-bit integer (0 to 255). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u16","title":"Writing U16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\nlocal num = 65_535\n\nmyBuffer:WriteU16(num)\n</code></pre> <p>Write an unsigned 16-bit integer (0 to 65,535). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u24","title":"Writing U24","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(3)\nlocal num = 16_777_215\n\nmyBuffer:WriteU24(num)\n</code></pre> <p>Write an unsigned 24-bit integer (0 to 16,777,215). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u32","title":"Writing U32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 4_294_967_295\n\nmyBuffer:WriteU32(num)\n</code></pre> <p>Write an unsigned 32-bit integer (0 to 4,294,967,295). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u40","title":"Writing U40","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 1_099_511_627_775\n\nmyBuffer:WriteU40(num)\n</code></pre> <p>Write an unsigned 40-bit integer (0 to 1,099,511,627,775). Clamped.</p>"},{"location":"API/Buffer/Writing/#writing-u48","title":"Writing U48","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 281_474_976_710_655\n\nmyBuffer:WriteU48(num)\n</code></pre> <p>Write an unsigned 48-bit integer (0 to 281,474,976,710,655). Clamped and truncated.</p>"},{"location":"API/Buffer/Writing/#writing-u54","title":"Writing U54","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 18_014_398_509_481_980\n\nmyBuffer:WriteU54(num)\n</code></pre> <p>Write an unsigned 54-bit integer (0 to 18,014,398,509,481,980). Clamped and truncated.</p> <p>Note</p> <p>The maximum value is 18,014,398,509,481,984 but i clamped it to 18,014,398,509,481,980 cause it was causing a bug.</p>"},{"location":"API/Buffer/Writing/#writing-float","title":"Writing Float","text":"<p>For floating-point numbers, you will need to use methods like <code>:WriteF</code>, etc.</p>"},{"location":"API/Buffer/Writing/#writing-f16","title":"Writing F16","text":"<p><pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(2)\nlocal num = 1.545\n\nmyBuffer:WriteF16(num)\n</code></pre> Write a 16-bit float (half-precision) to the buffer. Lower precision than F32/F64, expect rounding.</p> <p>NaN/Inf are handled, finite values are encoded with sign/exponent/mantissa.</p>"},{"location":"API/Buffer/Writing/#writing-f32","title":"Writing F32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\nlocal num = 100.999\n\nmyBuffer:WriteF32(num)\n</code></pre> <p>Write a 32-bit float to the buffer.</p>"},{"location":"API/Buffer/Writing/#writing-f64","title":"Writing F64","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\nlocal num = 100.9999999999\n\nmyBuffer:WriteF64(num)\n</code></pre> <p>Write a 64-bit float to the buffer.</p>"},{"location":"API/Buffer/Writing/#writing-strings","title":"Writing Strings","text":"<p>For character strings, you must use methods like <code>:WriteString</code>, etc.</p>"},{"location":"API/Buffer/Writing/#writing-string8","title":"Writing String8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\n\nmyBuffer:WriteString8(\"Hello\",5)\n</code></pre> <p>Write a string clamped to max 8 characters.</p> <p><code>len</code> is the intended fixed length to write.</p> <p>The input string is truncated to <code>len</code> (clamped to [1, 8]).</p>"},{"location":"API/Buffer/Writing/#writing-string16","title":"Writing String16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(16)\n\nmyBuffer:WriteString16(\"Hello World\",11)\n</code></pre> <p>Write a string clamped to max 16 characters.</p> <p><code>len</code> is the intended fixed length to write.</p> <p>The input string is truncated to <code>len</code> (clamped to [1, 16]).</p>"},{"location":"API/Buffer/Writing/#writing-string32","title":"Writing String32","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(32)\n\nmyBuffer:WriteString32(\"Hello World\",11)\n</code></pre> <p>Write a string clamped to max 32 characters.</p> <p><code>len</code> is the intended fixed length to write.</p> <p>The input string is truncated to <code>len</code> (clamped to [1, 32]).</p>"},{"location":"API/Buffer/Writing/#writing-string64","title":"Writing String64","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(64)\n\nmyBuffer:WriteString32(\"Hello World\",11)\n</code></pre> <p>Write a string clamped to max 64 characters.</p> <p><code>len</code> is the intended fixed length to write.</p> <p>The input string is truncated to <code>len</code> (clamped to [1, 64]).</p>"},{"location":"API/Buffer/Writing/#writing-string","title":"Writing String","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(11)\n\nmyBuffer:WriteString(\"Hello World\")\n</code></pre> <p>Write a string without caring about length limits.</p> <p>Writes exactly #value bytes.</p> <p>Reader must know or infer the length (no prefix is written).</p>"},{"location":"API/Buffer/Writing/#writing-roblox-types","title":"Writing Roblox Types","text":"<p>For other types like boolean, vector, etc. please use <code>:Write[TypeName]</code>, etc.</p>"},{"location":"API/Buffer/Writing/#writing-bool1","title":"Writing Bool1","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nmyBuffer:WriteBool1(true)\n</code></pre> <p>Write a single boolean using 1 bit. - nil/false -&gt; 0, anything else -&gt; 1</p>"},{"location":"API/Buffer/Writing/#writing-bool8","title":"Writing Bool8","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(1)\n\nlocal arrayOfValues = {\n    true,\n    true,\n    false,\n    nil,\n    1,\n    true,\n    \"hello world\",\n    false\n}\n\n\nmyBuffer:WriteBool8(arrayOfValues)\n</code></pre> <p>Write 8 booleans packed into 1 byte.</p> <p>Accepts an array-like table of up to 8 values. Each truthy value sets the corresponding bit to 1.</p>"},{"location":"API/Buffer/Writing/#writing-instance","title":"Writing Instance","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(0) --&gt; byte are not required if you only write instance\n\nmyBuffer:WriteInstance(workspace.Baseplate)\n</code></pre> <p>Store an Instance in the side <code>instance_buffer</code>. Does not write anything to the raw byte buffer.</p> <p><code>instance_offset</code> is incremented to track count/index.</p>"},{"location":"API/Buffer/Writing/#writing-vector2","title":"Writing Vector2","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(16) \n\nlocal pos = Vector2.new(10.5,5.945)\n\nmyBuffer:WriteVector2(pos)\n</code></pre> <p>Write a Vector2 as two f64 (x, y).</p>"},{"location":"API/Buffer/Writing/#writing-vector3","title":"Writing Vector3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(24) \n\nlocal pos = workspace.Baseplate.Position\n\nmyBuffer:WriteVector3(pos)\n</code></pre> <p>Write a Vector3 as three f64 (x, y, z).</p>"},{"location":"API/Buffer/Writing/#writing-vector2int16","title":"Writing Vector2Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4) \n\nlocal pos = Vector2int16.new(10,5)\n\nmyBuffer:WriteVector2Int16(pos)\n</code></pre> <p>Write a Vector2int16 as two i16 (x, y). Values clamped to int16 range.</p>"},{"location":"API/Buffer/Writing/#writing-vector3int16","title":"Writing Vector3Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nlocal pos = Vector3int16.new(10,5,15)\n\nmyBuffer:WriteVector3Int16(pos)\n</code></pre> <p>Write a Vector3int16 as three i16 (x, y, z). Values clamped to int16 range.</p>"},{"location":"API/Buffer/Writing/#writing-cframe","title":"Writing CFrame","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(96)\n\nlocal cf = workspace.Baseplate.CFrame\n\nmyBuffer:WriteCFrame(cf)\n</code></pre> <p>Write a full-precision CFrame as 12 f64 components (position + rotation matrix).</p>"},{"location":"API/Buffer/Writing/#writing-lossycframe","title":"Writing LossyCFrame","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(48)\n\nlocal cf = workspace.Baseplate.CFrame\n\nmyBuffer:WriteLossyCFrame(cf)\n</code></pre> <p>Write a lossy (compressed) CFrame as 12 f32 components.</p>"},{"location":"API/Buffer/Writing/#writing-udim","title":"Writing UDim","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\n\nlocal CornerRadius = YourGui.UICorner.CornerRadius -- This is a UDim\n\nmyBuffer:WriteUDim(CornerRadius)\n</code></pre> <p>Write a UDim as two f32 (Scale, Offset).</p>"},{"location":"API/Buffer/Writing/#writing-udim2","title":"Writing UDim2","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(16)\n\nlocal pos = YourGui.Position -- This is a UDim2\n\nmyBuffer:WriteUDim2(pos)\n</code></pre> <p>Write a UDim2 as four f32 (X.Scale, Y.Scale, X.Offset, Y.Offset).</p>"},{"location":"API/Buffer/Writing/#writing-color3","title":"Writing Color3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(12)\n\nlocal color = Color3.new(1,1,1)\n\nmyBuffer:WriteColor3(color)\n</code></pre> <p>Write a Color3 as three f32 (r, g, b). Values clamped to float32 range [0f,1f] typically already valid.</p>"},{"location":"API/Buffer/Writing/#writing-rect","title":"Writing Rect","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(32)\n\nlocal rect1 = Rect.new(Vector2.new(10, 10), Vector2.new(80, 80))\n\nmyBuffer:WriteRect(rect1)\n</code></pre> <p>Write a Rect as two Vector2 (Min, Max) using f64.</p> <p>Relies on WriteVector2 to do the actual writing and offset increments.</p>"},{"location":"API/Buffer/Writing/#writing-region3","title":"Writing Region3","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(120)\n\nlocal region = Region3.new(\n    Vector3.new(0, 0, 0),\n    Vector3.new(20, 20, 20)\n)\n\nmyBuffer:WriteRegion3(region)\n</code></pre> <p>Write a Region3 as CFrame + Size.</p> <p>Intended: CFrame (12 f64 = 96 bytes) + Vector3 (3 f64 = 24 bytes) = 120 bytes.</p>"},{"location":"API/Buffer/Writing/#writing-region3int16","title":"Writing Region3Int16","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(12)\n\nlocal region = Region3int16.new(\n    Vector3int16.new(0, 0, 0),\n    Vector3int16.new(50, 100, 50)\n)\n\nmyBuffer:WriteRegion3int16(region)\n</code></pre> <p>Write a Region3int16 as two Vector3int16 (Max then Min).</p>"},{"location":"API/Buffer/Writing/#writing-vector-luau-library","title":"Writing Vector (luau library)","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(24)\n\n--the current vector library\nlocal vect = vector.create(10,1,1)\n\nmyBuffer:WriteVector(vect) -- YOU CAN USE :WriteVector3() AS WELL\n</code></pre> <p>Write a vector with the 'vector' luau linenums=\"1\" library </p> <ul> <li>24 bytes total.</li> </ul>"},{"location":"API/Buffer/Writing/#writing-enum","title":"Writing Enum","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(4)\n\nmyBuffer:WriteEnum(Enum.KeyCode.A) -- or any enumItem you want\n</code></pre> <p>Writes an EnumItem to the buffer using a compact 4-byte format.</p> <p>The enum is stored as:</p> <ul> <li>2 bytes (U16): Enum type ID</li> <li>2 bytes (U16): Enum item value</li> </ul>"},{"location":"API/Buffer/Writing/#writing-rotationcurvekey","title":"Writing RotationCurveKey","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(218)\n\nlocal key = RotationCurveKey.new(1.5, CFrame.new(), Enum.KeyInterpolationMode.Linear)\nmyBuffer:WriteRotationCurveKey(key) -- Writes 104 bytes\n\nlocal cubicKey = RotationCurveKey.new(2.0, CFrame.Angles(0, math.pi, 0), Enum.KeyInterpolationMode.Cubic)\nmyBuffer:WriteRotationCurveKey(cubicKey) -- Writes 112 bytes with tangents\n</code></pre> <p>Writes a RotationCurveKey to the buffer with variable size based on interpolation mode.</p> <p>Total size:</p> <ul> <li>104 bytes for Linear/Constant interpolation</li> <li>112 bytes for Cubic interpolation (includes tangent data)</li> </ul> <p>Info</p> <ul> <li>Cubic interpolation requires additional storage for smooth curve tangents</li> <li>The tangent values control the curve's shape between keyframes</li> </ul>"},{"location":"API/Buffer/Writing/#writing-floatcurvekey","title":"Writing FloatCurveKey","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(40)\n\nlocal key = FloatCurveKey.new(0.5, 1.25, Enum.KeyInterpolationMode.Linear)\nmyBuffer:WriteFloatCurveKey(key) -- Writes 16 bytes\n\nlocal cubicKey = FloatCurveKey.new(1.0, 2.5, Enum.KeyInterpolationMode.Cubic)\ncubicKey.LeftTangent = 0.5\ncubicKey.RightTangent = 0.5\nmyBuffer:WriteFloatCurveKey(cubicKey) -- Writes 24 bytes with tangents\n</code></pre> <p>Write a FloatCurveKey to the buffer with variable size based on interpolation mode.</p> <p>Total size:</p> <ul> <li>16 bytes for Linear/Constant interpolation</li> <li>24 bytes for Cubic interpolation (includes tangent data)</li> </ul> <p>Info</p> <ul> <li>Value is stored as F64 for maximum precision in animation curves</li> <li>Tangents control the curve's acceleration/deceleration for smooth transitions</li> </ul>"},{"location":"API/Buffer/Writing/#writing-colorsequence","title":"Writing ColorSequence","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(49)\n\nlocal gradient = ColorSequence.new({\n    ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),    -- Red at start\n    ColorSequenceKeypoint.new(0.5, Color3.new(0, 1, 0)),  -- Green at middle\n    ColorSequenceKeypoint.new(1, Color3.new(0, 0, 1))     -- Blue at end\n})\nmyBuffer:WriteColorSequence(gradient) -- Writes 49 bytes (1 + 3*16)\n</code></pre> <p>Writes a ColorSequence to the buffer with all its keypoints.</p> <p>Total size: 1 + (16 * keypoint_count) bytes</p> <p>Info</p> <ul> <li>Color values are converted from Roblox's 0-1 range to 0-255 for storage</li> <li>Keypoints are written in their original order</li> </ul> <p>Warning</p> <ul> <li>Maximum 255 keypoints due to U8 count storage.</li> </ul>"},{"location":"API/Buffer/Writing/#writing-numberrange","title":"Writing NumberRange","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(8)\n\nBuffer:WriteNumberRange(NumberRange.new(0, 10))\n</code></pre> <p>Writes a NumberRange to the buffer using a compact 8-byte layout.</p> <p>Info</p> <ul> <li>Values are written as provided; no clamping or reordering is performed</li> <li>Uses F32 for both fields to keep the footprint small and consistent</li> </ul>"},{"location":"API/Buffer/Writing/#writing-numbersequence","title":"Writing NumberSequence","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(37)\n\nlocal seq = NumberSequence.new({\n    NumberSequenceKeypoint.new(0.0, 0.0),\n    NumberSequenceKeypoint.new(0.5, 1.0, 0.25),\n    NumberSequenceKeypoint.new(1.0, 0.0),\n})\n\nmyBuffer:WriteNumberSequence(seq)\n</code></pre> <p>Writes a NumberSequence to the buffer with all its keypoints.</p> <p>Total size: 1 + (12 * keypoint_count) bytes</p> <p>Info</p> <ul> <li>Envelope is written for every keypoint (0 if not used)</li> <li>Keypoints are written in their original order</li> </ul> <p>Warning</p> <ul> <li>Maximum of 255 keypoints due to U8 count storage.</li> </ul>"},{"location":"API/Buffer/Writing/#custom-writing","title":"Custom Writing","text":""},{"location":"API/Buffer/Writing/#writeas","title":"WriteAs","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myBuffer = Buffer.create(14)\n\n--[[\n    For all string type please define the length at the end\n    or this will not work\n]]\nmyBuffer:WriteAs(\"String\",\"Hello World !!\",14)\n</code></pre> <p>Write any target type to the buffer</p> <p>Warning</p> <ul> <li>Use specific Write functions when possible for better performance</li> </ul> <p>Params :</p> <ul> <li>@param valueType: ValueType - Type of value to write</li> <li>@param value: T - Value to write</li> <li>@param __optionalParam: any? - Optional parameter (e.g. string length)</li> </ul>"},{"location":"API/Buffer/Writing/#writearray","title":"WriteArray","text":"<pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal my_buffer = Buffer.create(145)\n\nlocal schema = {\n    {Type =  \"String\",Length = 8},\n    \"RotationCurveKey\",\n    \"ColorSequence\"\n}\n\nlocal value = {\n    \"Hello World !!\", -- will be \"Hello Wo\" (limit to 8 characters)\n    RotationCurveKey.new(0,workspace.Baseplate.CFrame,Enum.KeyInterpolationMode.Linear),\n    ColorSequence.new({\n        ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),\n        ColorSequenceKeypoint.new(1,Color3.new(1,1,1)),\n    })\n}\n\nmy_buffer:WriteArray(schema,value)\n</code></pre> <p>Writes an array of typed values to the buffer.</p> <ul> <li>@param array {ValueType} - Array of value types (e.g., \"U8\", \"Float32\", \"String16\")</li> <li>@param value {T} - Array of corresponding values to write</li> </ul> <p>Info</p> <p>For complex types (e.g String) please use the example above this function is different from <code>WriteAs</code>,</p> <p>for String8 etc... you can use the normal way this only apply for <code>undefined-string length</code>.</p> <p>Also note that the order is important.</p>"},{"location":"API/Collect/","title":"Overview","text":""},{"location":"API/Collect/#getting-started","title":"Getting Started","text":"<p>Collect: A garbage collection/cleanup utility module</p> <p>Manages and cleans up various types of resources (connections, instances, threads, etc.)</p>"},{"location":"API/Collect/#version","title":"Version","text":""},{"location":"API/Collect/#collect-v12","title":"Collect V1.2","text":""},{"location":"API/Collect/Advanced/","title":"Advanced","text":""},{"location":"API/Collect/Advanced/#getting-started","title":"Getting Started","text":"<p>This page is reserved for advanced stuff or for metamethods like <code>__len</code>, <code>__sub</code> and <code>__add</code> etc...</p>"},{"location":"API/Collect/Advanced/#metamethods","title":"Metamethods","text":""},{"location":"API/Collect/Advanced/#__add","title":"__add","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal Component = Collect.new()\n\n-- Add a part to the cleanup list (e.g is the same as calling :Add(workspace.Baseplate) )\nComponent += workspace.Baseplate\n</code></pre>"},{"location":"API/Collect/Advanced/#__sub","title":"__sub","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal Component = Collect.new()\n\n-- Removed a part to the cleanup list (e.g is the same as calling :Remove(workspace.Baseplate) )\nComponent -= workspace.Baseplate\n</code></pre>"},{"location":"API/Collect/Advanced/#__tostring","title":"__tostring()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal Component = Collect.new()\n\nComponent += workspace.Baseplate\n\nprint(Component) --&gt; output : CollectComponent(1) -- 1 is the number of items in the cleanup list\n</code></pre>"},{"location":"API/Collect/Advanced/#__len","title":"__len()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal Component = Collect.new()\n\nComponent += workspace.Baseplate\n\nprint(#Component) --&gt; 1 Prints the number of clean-up items in the component\n</code></pre>"},{"location":"API/Collect/Methods/","title":"Methods","text":""},{"location":"API/Collect/Methods/#getting-started","title":"Getting Started","text":"<p>All information for each function will be explained here.</p>"},{"location":"API/Collect/Methods/#methods","title":"Methods","text":""},{"location":"API/Collect/Methods/#collectnew-constructor","title":"Collect.new() (Constructor)","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n</code></pre> <p>Creates a new CollectComponent instance</p> <p>@return: New CollectComponent for managing cleanup tasks</p>"},{"location":"API/Collect/Methods/#collectadd","title":"Collect:Add()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Baseplate)\n</code></pre> <p>Adds an item to be tracked and cleaned up later</p> <p>@param object: Item to track (function, connection, instance, thread, or table with cleanup method)</p>"},{"location":"API/Collect/Methods/#collectremove","title":"Collect:Remove()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Remove(workspace.Baseplate)\n</code></pre> <p>Removes a specific item from tracking</p> <ul> <li>@param object: Item to remove</li> <li>@param clean (optional default true) : If true, calls cleanup on the item</li> </ul>"},{"location":"API/Collect/Methods/#collectfind","title":"Collect:Find()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Baseplate)\n\nlocal myBaseplate = garbage:Find(workspace.Baseplate) --&gt; this will return the object\n</code></pre> <p>Finds an item in the tracked list</p> <ul> <li>@param object: Item to find</li> <li>@return: The item if found, nil otherwise</li> </ul>"},{"location":"API/Collect/Methods/#collectfindallfunc","title":"Collect:FindAllFunc()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(function()\n    print(\"cleaning\")\nend)\n\nprint(garbage:FindAllFunc()) -&gt; {function}\n</code></pre> <p>Returns all tracked functions</p> <ul> <li>@return: Array of function items</li> </ul>"},{"location":"API/Collect/Methods/#collectfindallsignal","title":"Collect:FindAllSignal()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Baseplate.Changed:Connect(callback))\n\nprint(garbage:FindAllSignal()) -&gt; {RBXScriptConnection}\n</code></pre> <p>Returns all tracked connections (RBXScriptConnections)</p> <ul> <li>@return: Array of connection items</li> </ul>"},{"location":"API/Collect/Methods/#collectfindallconstructor","title":"Collect:FindAllConstructor()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\nlocal class = {\n    Destroy = function()\n        print(\"cleaning...\")\n    end\n}\n\ngarbage:Add(class) --&gt; for constructor with the .new method use :Construct(your_constructor)\n\nprint(garbage:FindAllConstructor()) -&gt; {ClassLike}\n</code></pre> <p>Returns all tracked objects with cleanup methods (custom classes)</p> <ul> <li>@return: Array of objects with cleanup methods</li> </ul>"},{"location":"API/Collect/Methods/#collectfindallinstance","title":"Collect:FindAllInstance()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Part)\n\nprint(garbage:FindAllInstance()) -&gt; {Instance}\n</code></pre> <p>Returns all tracked Roblox instances</p> <ul> <li>@return: Array of Instance objects</li> </ul>"},{"location":"API/Collect/Methods/#collectfindallthread","title":"Collect:FindAllThread()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(task.spawn(function() --&gt; you can use coroutine but it must return a thread.\n    print(\"my thread\")\nend))\n\nprint(garbage:FindAllThread()) -&gt; {Thread}\n</code></pre> <p>Returns all tracked threads</p> <ul> <li>@return: Array of thread objects</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveall","title":"Collect:RemoveAll()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Baseplate)\ngarbage:Add(workspace.Baseplate.Changed:Connect(yourCallback))\n\ngarbage:Add(function()\n    print(\"cleaning\")\nend)\n\ngarbage:RemoveAll()\n</code></pre> <p>Removes all tracked items</p> <ul> <li>@param clean (optional default true) : If true, calls cleanup on all items</li> <li>@param ...: Additional arguments passed to cleanup methods</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveallsignal","title":"Collect:RemoveAllSignal()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Baseplate.Change:Connect(callback))\n\ngarbage:RemoveAllSignal()\n</code></pre> <p>Removes all connections from tracking</p> <ul> <li>@param clean (optional default true) : If true, disconnects all connections</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveallfunc","title":"Collect:RemoveAllFunc()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(function(...)\n    print(...)\nend)\n\ngarbage:RemoveAllFunc()\n</code></pre> <p>Removes all functions from tracking</p> <ul> <li>@param clean: If true, calls all function</li> <li>@param ...: Arguments passed to functions</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveallconstructor","title":"Collect:RemoveAllConstructor()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\nlocal class = {\n    Destroy = function()\n        print(\"cleaning\")\n    end\n}\n\ngarbage:Add(class)\n\ngarbage:RemoveAllConstructor(true,...) --&gt; if true it will call .Destroy\n</code></pre> <p>Removes all objects with cleanup methods from tracking</p> <ul> <li>@param clean (optional default true) : If true, calls cleanup methods</li> <li>@param ...: Arguments passed to cleanup methods</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveallinstance","title":"Collect:RemoveAllInstance()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(workspace.Part)\n\ngarbage:RemoveAllInstance()\n</code></pre> <p>Removes all Roblox instances from tracking</p> <ul> <li>@param clean (optional default true) : If true, destroys all instances</li> </ul>"},{"location":"API/Collect/Methods/#collectremoveallthread","title":"Collect:RemoveAllThread()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Add(your_thread)\n\ngarbage:RemoveAllThread()\n</code></pre> <p>Removes all threads from tracking</p> <ul> <li>@param clean (optional default true) : If true, cancels all threads</li> </ul>"},{"location":"API/Collect/Methods/#collectconstruct","title":"Collect:Construct()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal constructor = {\n    new = function()\n        return {\n            Destroy = function()\n                print(\"cleaning\")\n            end\n        }\n    end\n}\n\nlocal garbage = Collect.new()\n\ngarbage:Construct(constructor)\n</code></pre> <p>Creates a new object and adds it to tracking</p> <ul> <li>@param class: Class constructor (table with .new or function)</li> <li>@param ...: Arguments for constructor</li> <li>@return: The created object</li> </ul>"},{"location":"API/Collect/Methods/#collectextend","title":"Collect:Extend()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\nlocal extended_garbage = garbage:Extend()\n\ngarbage:Clean() --&gt; will clean \"extended_garbage\" too\n</code></pre> <p>Creates a new CollectComponent as a child of this one</p> <ul> <li>@return: New CollectComponent that will be cleaned with parent</li> </ul>"},{"location":"API/Collect/Methods/#collectmerge","title":"Collect:Merge()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\nlocal other_garbage = Collect.new()\n\nother_garbage:Add(workspace.Baseplat)\n\ngarbage:Merge(other_garbage) --&gt; merge all current tasks in \"other_garbage\" in this one\n</code></pre> <p>Merges another CollectComponent into this one, taking ownership of all its tracked items</p> <p>The source component is destroyed after merging</p> <ul> <li>@param self: Target CollectComponent that will receive the items</li> <li>@param CollectComponent: Source CollectComponent to merge from (will be destroyed)</li> </ul>"},{"location":"API/Collect/Methods/#collectclean","title":"Collect:Clean()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\ngarbage:Clean() --&gt; clean everything and the component itself\n</code></pre> <p>Cleans up all tracked items and destroys the component</p> <p>This is the main cleanup method - call when done with the component</p>"},{"location":"API/Collect/Methods/#collectwrapclean","title":"Collect:WrapClean()","text":"<pre><code>local Collect = require(somewhere.Collect)\n\nlocal garbage = Collect.new()\n\nlocal clean = garbage:WrapClean() \n\nclean() --&gt; clean everything and the component itself\n</code></pre> <p>Returns a function that cleans this component when called</p> <p>Useful for passing cleanup to other systems</p> <ul> <li>@return: Function that calls Clean()</li> </ul>"},{"location":"API/Collect/Methods/#alias","title":"Alias","text":"<pre><code>-- Create alias for Constructor methods\nConstructor.New = Constructor.new\n\n-- Create alias for Component methods\nComponent.add = Component.Add\nComponent.remove = Component.Remove\nComponent.removeAll = Component.RemoveAll\nComponent.removeAllFunc = Component.RemoveAllFunc\nComponent.removeAllSignal = Component.RemoveAllSignal\nComponent.removeAllThread = Component.RemoveAllThread\nComponent.removeAllInstance = Component.RemoveAllInstance\nComponent.removeAllConstructor = Component.RemoveAllConstructor\nComponent.find = Component.Find\nComponent.findAllFunc = Component.FindAllFunc\nComponent.findAllSignal = Component.FindAllSignal\nComponent.findAllThread = Component.FindAllThread\nComponent.findAllInstance = Component.FindAllInstance\nComponent.findAllConstructor = Component.FindAllConstructor\nComponent.construct = Component.Construct\nComponent.extend = Component.Extend\nComponent.merge = Component.Merge\nComponent.clean = Component.Clean\nComponent.destroy = Component.Clean\nComponent.Destroy = Component.Clean\nComponent.wrapClean = Component.WrapClean\n</code></pre>"},{"location":"API/ConnectionStore/","title":"Overview","text":""},{"location":"API/ConnectionStore/#getting-started","title":"Getting Started","text":"<p>ConnectionStore is a module for storing in a local or global registry. It stores threads/connections via a name. </p> <p>If the name is reassigned to another value, the old value will be cleaned.</p>"},{"location":"API/ConnectionStore/#version","title":"Version","text":""},{"location":"API/ConnectionStore/#connectionstore-v12","title":"ConnectionStore V1.2","text":""},{"location":"API/ConnectionStore/#methods","title":"Methods","text":""},{"location":"API/ConnectionStore/#local","title":"Local","text":"<p>See the list of functions for registering in the local registry.</p> <p>List:</p> <ul> <li> RegisterLocal</li> <li> UnregisterLocal</li> <li> GetLocalConnections</li> <li> GetLocal</li> <li> HasLocal</li> <li> UnregisterLocals</li> </ul>"},{"location":"API/ConnectionStore/#global","title":"Global","text":"<p>See the list of functions for registering in the global registry.</p> <p>List:</p> <ul> <li> RegisterGlobal</li> <li> UnregisterGlobal</li> <li> GetGlobalConnections</li> <li> GetGlobal</li> <li> HasGlobal</li> <li> UnregisterGlobals</li> </ul>"},{"location":"API/ConnectionStore/Global/","title":"Global","text":""},{"location":"API/ConnectionStore/Global/#getting-started","title":"Getting Started","text":"<p>In this page, you will learn everything about the methods for global registers.</p>"},{"location":"API/ConnectionStore/Global/#methods","title":"Methods","text":""},{"location":"API/ConnectionStore/Global/#registerglobal","title":"RegisterGlobal","text":"<p>Registers a connection &amp; thread in the global registry.</p> <p>If a connection &amp; thread with the same name already exists, it is disconnected first. This ensures only one active connection per name is stored.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.RegisterGlobal(\"ConnectionName\",workspace.Baseplate.Changed:Connect(function(property)\n    print(property)\nend)))\n</code></pre>"},{"location":"API/ConnectionStore/Global/#unregisterglobal","title":"UnregisterGlobal","text":"<p>Unregisters (removes) a connection &amp; thread from the global registry.</p> <p>If the connection is an RBXScriptConnection &amp; thread, it is disconnected before removal.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.UnregisterGlobal(\"ConnectionName\")\n</code></pre>"},{"location":"API/ConnectionStore/Global/#getglobalconnections","title":"GetGlobalConnections","text":"<p>Returns the entire global registry table.</p> <p>Useful for iterating over all stored global connections.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal connections = Connection.GetGlobalConnections()\n</code></pre>"},{"location":"API/ConnectionStore/Global/#getglobal","title":"GetGlobal","text":"<p>Retrieves a single connection by name from the global registry.</p> <p>Returns nil if the connection does not exist.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal conn = Connection.GetGlobal(\"ConnectionName\")\n\nprint(conn) --&gt; will print the actual RBXScriptConnection\n</code></pre>"},{"location":"API/ConnectionStore/Global/#hasglobal","title":"HasGlobal","text":"<p>Checks whether a connection with the given name exists in the global registry.</p> <p>Returns true if found, false otherwise.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal result = Connection.HasGlobal(\"ConnectionName\")\n\nprint(result) --&gt; will print true\n</code></pre>"},{"location":"API/ConnectionStore/Global/#unregisterglobals","title":"UnregisterGlobals","text":"<p>Disconnects and removes all connections from the global registry.</p> <p>Disconnects any RBXScriptConnection &amp; thread before clearing it from the table.</p> <p>Use this when you want to completely clear all local connections.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.UnregisterGlobals()\n</code></pre>"},{"location":"API/ConnectionStore/Local/","title":"Local","text":""},{"location":"API/ConnectionStore/Local/#getting-started","title":"Getting Started","text":"<p>In this page, you will learn everything about the methods for local registers.</p>"},{"location":"API/ConnectionStore/Local/#methods","title":"Methods","text":""},{"location":"API/ConnectionStore/Local/#registerlocal","title":"RegisterLocal","text":"<p>Registers a connection &amp; thread in the local registry.</p> <p>If a connection &amp; thread with the same name already exists, it is disconnected first. This ensures only one active connection per name is stored.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.RegisterLocal(\"ConnectionName\",workspace.Baseplate.Changed:Connect(function(property)\n    print(property)\nend)))\n</code></pre>"},{"location":"API/ConnectionStore/Local/#unregisterlocal","title":"UnregisterLocal","text":"<p>Unregisters (removes) a connection &amp; thread from the local registry.</p> <p>If the connection is an RBXScriptConnection &amp; thread, it is disconnected before removal.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.UnregisterLocal(\"ConnectionName\")\n</code></pre>"},{"location":"API/ConnectionStore/Local/#getlocalconnections","title":"GetLocalConnections","text":"<p>Returns the entire local registry table.</p> <p>Useful for iterating over all stored local connections.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal connections = Connection.GetLocalConnections()\n</code></pre>"},{"location":"API/ConnectionStore/Local/#getlocal","title":"GetLocal","text":"<p>Retrieves a single connection by name from the local registry.</p> <p>Returns nil if the connection does not exist.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal conn = Connection.GetLocal(\"ConnectionName\")\n\nprint(conn) --&gt; will print the actual RBXScriptConnection\n</code></pre>"},{"location":"API/ConnectionStore/Local/#haslocal","title":"HasLocal","text":"<p>Checks whether a connection with the given name exists in the local registry.</p> <p>Returns true if found, false otherwise.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nlocal result = Connection.HasLocal(\"ConnectionName\")\n\nprint(result) --&gt; will print true\n</code></pre>"},{"location":"API/ConnectionStore/Local/#unregisterlocals","title":"UnregisterLocals","text":"<p>Disconnects and removes all connections from the local registry.</p> <p>Disconnects any RBXScriptConnection &amp; thread before clearing it from the table.</p> <p>Use this when you want to completely clear all local connections.</p> <pre><code>local ConnectionStore = require(somewhere.ConnectionStore)\n\nConnection.UnregisterLocals()\n</code></pre>"},{"location":"API/Enum/","title":"Overview","text":""},{"location":"API/Enum/#getting-started","title":"Getting Started","text":"<p>This module provides a system for creating and managing enums in Luau.</p> <p>Enums are useful for creating named constants that represent specific values, making code more readable and maintainable.</p> <p>Features:</p> <ul> <li>Create enums with string keys and numeric values</li> <li>Automatic value assignment based on order</li> <li>Enum caching to prevent duplicate creation</li> <li>Type-safe enum access</li> <li>Frozen enums to prevent modification</li> </ul>"},{"location":"API/Enum/#version","title":"Version","text":""},{"location":"API/Enum/#enum-v11","title":"Enum V1.1","text":""},{"location":"API/Enum/Methods/","title":"Methods","text":""},{"location":"API/Enum/Methods/#getting-started","title":"Getting Started","text":"<p>For enum creation, everything will happen here.</p>"},{"location":"API/Enum/Methods/#methods","title":"Methods","text":""},{"location":"API/Enum/Methods/#creating-new-enums","title":"Creating new enums","text":"<pre><code>-- Import the main Enum module that provides enum creation functionality\nlocal EnumModule = require(somewhere.Enum.Enum)\n\n-- Import the EnumType module that contains type definitions for enums\nlocal EnumType = require(somewhere.Enum.EnumType)\n\n--[[\n    Creates a new enum called \"Hello-World\" with three values: A, B, and C\n\n    The type casting :: {EnumType.HelloKeys} ensures type safety by specifying\n    that the items array should match the HelloKeys type definition.\n\n    The final type cast :: EnumType.HelloEnum&lt;\"Hello\"&gt; ensures the returned\n    enum matches the expected HelloEnum type structure.\n\n    This creates an enum where:\n    - HelloEnum.A = {Value = 1, Name = \"A\", EnumType = \"Hello-World\"}\n    - HelloEnum.B = {Value = 2, Name = \"B\", EnumType = \"Hello-World\"}\n    - HelloEnum.C = {Value = 3, Name = \"C\", EnumType = \"Hello-World\"}\n]]\n\nlocal HelloEnum = EnumModule.new(\"Hello-World\",{\"A\",\"B\",\"C\"} :: {EnumType.HelloKeys}) :: EnumType.HelloEnum&lt;\"Hello\"&gt; \n-- You can name \"Hello\" What ever you want it will not be The EnumType \n</code></pre> <p>Creates a new enum with the given name and items.</p> <p>If an enum with the same name already exists, returns the existing enum. Otherwise, creates a new enum with auto-assigned numeric values.</p> <ul> <li>@param EnumName The unique name for this enum</li> <li>@param items Array of string keys for the enum values</li> <li>@return A frozen table mapping keys to EnumIndex objects</li> </ul>"},{"location":"API/Enum/Methods/#creating-enum-type-definition","title":"Creating Enum-Type definition","text":"<p>I recommend to put your Enum type definition inside EnumType this is where your gonna find the Enum type definition example.</p> <pre><code>-- Example enum type definitions\n-- These demonstrate how to create type-safe enum definitions\n\n-- HelloKeys defines the allowed string values for the Hello enum\n-- Using a union type ensures only these specific strings can be used\nexport type HelloKeys = \"A\" | \"B\" | \"C\"\n\n-- HelloEnum defines the structure of the Hello enum\n-- It maps each key to an EnumIndex with the appropriate enum name\n-- The generic parameter EnumName allows flexibility in the enum type name\nexport type HelloEnum&lt;EnumName = string&gt; = {\n    A: EnumIndex&lt;EnumName&gt;,  -- Enum item A\n    B: EnumIndex&lt;EnumName&gt;,  -- Enum item B\n    C: EnumIndex&lt;EnumName&gt;,  -- Enum item C\n}\n</code></pre>"},{"location":"API/Enum/Methods/#enumfrom","title":"Enum.from()","text":"<pre><code>-- Import the main Enum module that provides enum creation functionality\nlocal EnumModule = require(somewhere.Enum.Enum)\n\n-- Import the EnumType module that contains type definitions for enums\nlocal EnumType = require(somewhere.Enum.EnumType)\n\nlocal HelloEnum = EnumModule.new(\"Hello-World\",{\"A\",\"B\",\"C\"} :: {EnumType.HelloKeys}) :: EnumType.HelloEnum&lt;\"Hello\"&gt;\n\n--later in your code\n\nlocal HelloEnum = EnumModule.from(\"Hello-World\") :: EnumType.HelloEnum&lt;\"Hello\"&gt;\n</code></pre> <p>Retrieves an existing enum by name from the registry.</p> <ul> <li>@param EnumName The name of the enum to retrieve</li> <li>@return A frozen copy of the enum table</li> <li>@error Throws if the enum doesn't exist</li> </ul>"},{"location":"API/Enum/Methods/#enumremoveenum","title":"Enum.RemoveEnum()","text":"<pre><code>-- Import the main Enum module that provides enum creation functionality\nlocal EnumModule = require(somewhere.Enum.Enum)\n\n-- Import the EnumType module that contains type definitions for enums\nlocal EnumType = require(somewhere.Enum.EnumType)\n\nlocal HelloEnum = EnumModule.new(\"Hello-World\",{\"A\",\"B\",\"C\"} :: {EnumType.HelloKeys}) :: EnumType.HelloEnum&lt;\"Hello\"&gt;\n\n--later in your code\n\nEnumModule.RemoveEnum(\"Hello-World\")\n</code></pre> <p>Removes an enum from the registry.</p> <p>This clears the enum table and removes it from the registry, allowing a new enum with the same name to be created.</p> <ul> <li>@param EnumName The name of the enum to remove</li> </ul>"},{"location":"API/Enum/Methods/#alias","title":"Alias","text":"<pre><code>-- Alias for backward compatibility or alternative naming preference\n-- GetEnumItems provides the same functionality as 'from'\nEnumConstructor.GetEnumItems = EnumConstructor.from\n</code></pre>"},{"location":"API/Nexus/","title":"Overview","text":""},{"location":"API/Nexus/#getting-started","title":"Getting Started","text":"<p>Nexus Networking Module</p> <p>A simple networking solution for Roblox that provides basic client-server communication without complex buffer handling.</p>"},{"location":"API/Nexus/#version","title":"Version","text":""},{"location":"API/Nexus/#nexus-v101","title":"Nexus V1.0.1","text":""},{"location":"API/Nexus/Types/RemoteEvent/","title":"RemoteEvent","text":""},{"location":"API/Nexus/Types/RemoteEvent/#getting-started","title":"Getting Started","text":"<p>On this page you will learn how to create and connect a RemoteEvent from both the client and server side.</p>"},{"location":"API/Nexus/Types/RemoteEvent/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyRemoteEvent = Nexus.Server.RemoteEvent.new(\"MyRemoteEvent\")\n\nMyRemoteEvent:Connect(function(player,...)\n    print(\"Player fired MyRemoteEvent with args:\", ...)\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyRemoteEvent = Nexus.Client.RemoteEvent.new(\"MyRemoteEvent\")\n\nMyRemoteEvent:Fire(\"Hello World\",10)\n</code></pre> <p>This will print \"Player fired MyRemoteEvent with args ...\"</p>"},{"location":"API/Nexus/Types/RemoteEvent/#methods","title":"Methods","text":""},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventnew-constructor","title":"RemoteEvent.new() (Constructor)","text":"<p><code>RemoteEvent.new(name : string)</code></p> <p>@Server</p> <p>Creates a new RemoteEvent wrapper instance for server-side usage</p> <ul> <li>@param Name: The name of the RemoteEvent to wrap</li> <li>@return: New RemoteEventComponent instance</li> <li>@error: Throws if called from client</li> </ul> <p>@Client</p> <p>Creates a new RemoteEvent wrapper instance</p> <ul> <li>@param Name: The name of the RemoteEvent to wrap</li> <li>@return: New RemoteEventComponent instance</li> <li>@error: Throws if called from server or if RemoteEvent not found</li> </ul>"},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventconnect","title":"RemoteEvent:Connect()","text":"<p>@Server</p> <p><code>RemoteEvent:Connect(callback: (Player, T...) -&gt; ()): () -&gt; ()</code></p> <p>Creates a persistent connection to handle client events</p> <ul> <li>@param callback: Function to execute when event is received from client (includes Player parameter)</li> <li>@return: Disconnect function to remove the connection</li> </ul> <p>@Client</p> <p><code>RemoteEvent:Connect(callback: (T...) -&gt; ()): () -&gt; ()</code></p> <p>Creates a persistent connection to the RemoteEvent</p> <ul> <li>@param callback: Function to execute when event is received from server</li> <li>@return: Disconnect function to remove the connection</li> </ul>"},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventfire","title":"RemoteEvent:Fire()","text":"<p>@Server</p> <p><code>RemoteEvent:Fire(Player: Player, ...: T...)</code></p> <p>Fires the RemoteEvent to a specific client </p> <ul> <li>@param Player: Target player to send the event to</li> <li>@param ...: Variable arguments to send to client</li> </ul> <p>@Client</p> <p><code>RemoteEvent:Fire(...: T...)</code></p> <p>Fires the RemoteEvent to the server</p> <ul> <li>@param ...: Variable arguments to send to server</li> </ul>"},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventonce","title":"RemoteEvent:Once()","text":"<p>@Server</p> <p><code>RemoteEvent:Once(callback: (Player, T...) -&gt; ())</code></p> <p>Creates a one-time connection that auto-disconnects after first trigger</p> <ul> <li>@param callback: Function to execute once when event is received from client</li> </ul> <p>@Client</p> <p><code>RemoteEvent:Once(callback: (T...) -&gt; ())</code></p> <p>Creates a one-time connection that auto-disconnects after first trigger </p> <ul> <li>@param callback: Function to execute once when event is received</li> </ul>"},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventdisconnectall","title":"RemoteEvent:DisconnectAll()","text":"<p><code>RemoteEvent:DisconnectAll()</code></p> <p>Disconnects all active connections for this RemoteEvent</p>"},{"location":"API/Nexus/Types/RemoteEvent/#remoteeventdestroy","title":"RemoteEvent:Destroy()","text":"<p><code>RemoteEvent:Destroy()</code></p> <p>Destroys the RemoteEvent wrapper and cleans up all resources</p>"},{"location":"API/Nexus/Types/RemoteEvent/#alias","title":"Alias","text":"<pre><code>-- Constructor method aliases\nConstructor.find = Constructor.new\nConstructor.get = Constructor.new\nConstructor.Get = Constructor.new\nConstructor.Find = Constructor.new\nConstructor.New = Constructor.new\n\n-- Component method aliases (camelCase convention)\nComponent.connect = Component.Connect\nComponent.fire = Component.Fire\nComponent.destroy = Component.Destroy\nComponent.once = Component.Once\nComponent.disconnectAll = Component.DisconnectAll\n</code></pre>"},{"location":"API/Nexus/Types/RemoteFunction/","title":"RemoteFunction","text":""},{"location":"API/Nexus/Types/RemoteFunction/#getting-started","title":"Getting Started","text":"<p>On this page you will learn how to properly handle a RemoteFunction from both the client and server side.</p>"},{"location":"API/Nexus/Types/RemoteFunction/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyRemoteFunction = Nexus.Server.RemoteFunction.new(\"MyRemoteFunction\")\n\nMyRemoteFunction:Handle(function(player, ...)\n    print(player,...)\n    return math.random(0,100)\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyRemoteFunction = Nexus.Client.RemoteFunction.new(\"MyRemoteFunction\")\n\nlocal num = MyRemoteFunction:Invoke(\"Give me my number !!\")\nprint(num)\n</code></pre> <p>This will print and return the number generated on the server side.</p>"},{"location":"API/Nexus/Types/RemoteFunction/#methods","title":"Methods","text":""},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctionnew-constructor","title":"RemoteFunction.new() (Constructor)","text":"<p><code>RemoteFunction.new(name : string)</code></p> <p>@Server</p> <p>Creates a new RemoteFunction wrapper instance for server-side usage</p> <ul> <li>@param Name: The name of the RemoteFunction to wrap</li> <li>@return: New RemoteFunctionComponent instance</li> <li>@error: Throws if called from client</li> </ul> <p>@Client</p> <p>Creates a new RemoteFunction wrapper instance</p> <ul> <li>@param Name: The name of the RemoteFunction to wrap</li> <li>@return: New RemoteFunctionComponent instance</li> <li>@error: Throws if called from server or if RemoteFunction not found</li> </ul>"},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctionhandle","title":"RemoteFunction:Handle()","text":"<p>@Server</p> <p><code>RemoteFunction:Handle(callback: (Player, T...) -&gt; T...)</code></p> <p>Sets the callback function to handle client invocations</p> <ul> <li>@param callback: Function to execute when invoked by client (includes Player parameter)</li> <li>@return: Self for method chaining</li> </ul> <p>@Client</p> <p><code>RemoteFunction:Handle(callback: (T...) -&gt; T...)</code></p> <p>Sets the callback function to handle server invocations</p> <ul> <li>@param callback: Function to execute when invoked by server</li> <li>@return: Self for method chaining</li> </ul>"},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctioninvoke","title":"RemoteFunction:Invoke()","text":"<p>@Server</p> <p><code>RemoteFunction:Invoke(Player,... : T...) : any</code></p> <p>Invokes the RemoteFunction on a specific client with timeout protection</p> <ul> <li>@param Player: Target player to invoke the function on</li> <li>@param ...: Variable arguments to send to client</li> <li>@return: Response from client or nil if timeout</li> </ul> <p>@Client</p> <p><code>RemoteFunction:Invoke(... : T...) : any</code></p> <p>Invokes the RemoteFunction on the server with timeout protection</p> <ul> <li>@param ...: Variable arguments to send to server</li> <li>@return: Response from server or nil if timeout</li> </ul>"},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctionremovehandler","title":"RemoteFunction:RemoveHandler()","text":"<p><code>RemoteFunction:RemoveHandler()</code></p> <p>Removes the current handler function</p> <ul> <li>@return: Self for method chaining</li> </ul>"},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctionsettimeout","title":"RemoteFunction:SetTimeout()","text":"<p><code>RemoteFunction:SetTimeout(n : number)</code></p> <p>Sets the invocation timeout duration</p> <ul> <li>@param n: Timeout duration in seconds</li> <li>@return: Self for method chaining</li> </ul>"},{"location":"API/Nexus/Types/RemoteFunction/#remotefunctiondestroy","title":"RemoteFunction:Destroy()","text":"<p><code>RemoteFunction:Destroy()</code></p> <p>Destroys the RemoteFunction wrapper and cleans up all resources</p>"},{"location":"API/Nexus/Types/RemoteFunction/#alias","title":"Alias","text":"<pre><code>-- Constructor method aliases\nConstructor.find = Constructor.new\nConstructor.get = Constructor.new\nConstructor.Get = Constructor.new\nConstructor.Find = Constructor.new\nConstructor.New = Constructor.new\n\n-- Component method aliases (camelCase convention)\nComponent.invoke = Component.Invoke\nComponent.handle = Component.Handle\nComponent.destroy = Component.Destroy\nComponent.removeHandler = Component.RemoveHandler\nComponent.setTimeout = Component.SetTimeout\n</code></pre>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/","title":"UnreliableRemoteEvent","text":""},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#getting-started","title":"Getting Started","text":"<p>On this page you will learn how to create and connect an UnreliableRemoteEvent from both the client and server side.</p>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyUnreliableRemoteEvent = Nexus.Server.UnreliableRemoteEvent.new(\"MyUnreliableRemoteEvent\")\n\nMyUnreliableRemoteEvent:Connect(function(player,...)\n    print(\"Player fired MyUnreliableRemoteEvent with args:\", ...)\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Nexus = require(somewhere.Nexus)\n\nlocal MyUnreliableRemoteEvent = Nexus.Client.UnreliableRemoteEvent.new(\"MyUnreliableRemoteEvent\")\n\nMyUnreliableRemoteEvent:Fire(\"Hello World\",10)\n</code></pre> <p>This will print \"Player fired MyUnreliableRemoteEvent with args ...\"</p>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#methods","title":"Methods","text":""},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventnew-constructor","title":"UnreliableRemoteEvent.new() (Constructor)","text":"<p><code>UnreliableRemoteEvent.new(name : string)</code></p> <p>@Server</p> <p>Creates a new UnreliableRemoteEvent wrapper instance for server-side usage</p> <ul> <li>@param Name: The name of the UnreliableRemoteEvent to wrap</li> <li>@return: New UnreliableRemoteEventComponent instance</li> <li>@error: Throws if called from client</li> </ul> <p>@Client</p> <p>Creates a new UnreliableRemoteEvent wrapper instance</p> <ul> <li>@param Name: The name of the UnreliableRemoteEvent to wrap</li> <li>@return: New UnreliableRemoteEventComponent instance</li> <li>@error: Throws if called from server or if UnreliableRemoteEvent not found</li> </ul>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventconnect","title":"UnreliableRemoteEvent:Connect()","text":"<p>@Server</p> <p><code>UnreliableRemoteEvent:Connect(callback: (Player, T...) -&gt; ()): () -&gt; ()</code></p> <p>Creates a persistent connection to handle client events</p> <ul> <li>@param callback: Function to execute when event is received from client (includes Player parameter)</li> <li>@return: Disconnect function to remove the connection</li> </ul> <p>@Client</p> <p><code>UnreliableRemoteEvent:Connect(callback: (T...) -&gt; ()): () -&gt; ()</code></p> <p>Creates a persistent connection to the UnreliableRemoteEvent</p> <ul> <li>@param callback: Function to execute when event is received from server</li> <li>@return: Disconnect function to remove the connection</li> </ul>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventfire","title":"UnreliableRemoteEvent:Fire()","text":"<p>@Server</p> <p><code>UnreliableRemoteEvent:Fire(Player: Player, ...: T...)</code></p> <p>Fires the UnreliableRemoteEvent to a specific client</p> <ul> <li>@param Player: Target player to send the event to</li> <li>@param ...: Variable arguments to send to client</li> </ul> <p>@Client</p> <p><code>UnreliableRemoteEvent:Fire(...: T...)</code></p> <p>Fires the UnreliableRemoteEvent to the server</p> <ul> <li>@param ...: Variable arguments to send to server</li> </ul>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventonce","title":"UnreliableRemoteEvent:Once()","text":"<p>@Server</p> <p><code>UnreliableRemoteEvent:Once(callback: (Player, T...) -&gt; ())</code></p> <p>Creates a one-time connection that auto-disconnects after first trigger</p> <ul> <li>@param callback: Function to execute once when event is received from client</li> </ul> <p>@Client</p> <p><code>UnreliableRemoteEvent:Once(callback: (T...) -&gt; ())</code></p> <p>Creates a one-time connection that auto-disconnects after first trigger</p> <ul> <li>@param callback: Function to execute once when event is received</li> </ul>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventdisconnectall","title":"UnreliableRemoteEvent:DisconnectAll()","text":"<p><code>UnreliableRemoteEvent:DisconnectAll()</code></p> <p>Disconnects all active connections for this UnreliableRemoteEvent</p>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#unreliableremoteeventdestroy","title":"UnreliableRemoteEvent:Destroy()","text":"<p><code>UnreliableRemoteEvent:Destroy()</code></p> <p>Destroys the UnreliableRemoteEvent wrapper and cleans up all resources</p>"},{"location":"API/Nexus/Types/UnreliableRemoteEvent/#alias","title":"Alias","text":"<pre><code>-- Constructor method aliases\nConstructor.find = Constructor.new\nConstructor.get = Constructor.new\nConstructor.Get = Constructor.new\nConstructor.Find = Constructor.new\nConstructor.New = Constructor.new\n\n-- Component method aliases (camelCase convention)\nComponent.connect = Component.Connect\nComponent.fire = Component.Fire\nComponent.destroy = Component.Destroy\nComponent.once = Component.Once\nComponent.disconnectAll = Component.DisconnectAll\n</code></pre>"},{"location":"API/Option/","title":"Overview","text":""},{"location":"API/Option/#getting-started","title":"Getting Started","text":"<p>This module implements the Option type pattern, similar to Rust's Option. <p>It provides a way to handle nullable values in a type-safe manner.</p> <p>Option can be either: <ul> <li>Some(value): Contains a value of type T</li> <li>None: Contains no value</li> </ul>"},{"location":"API/Option/#version","title":"Version","text":""},{"location":"API/Option/#option-v12","title":"Option V1.2","text":""},{"location":"API/Option/Methods/","title":"Methods","text":""},{"location":"API/Option/Methods/#getting-started","title":"Getting Started","text":"<p>Option Module - Complete Function Reference</p>"},{"location":"API/Option/Methods/#methods","title":"Methods","text":""},{"location":"API/Option/Methods/#optionsome-constructor","title":"Option.Some (Constructor)","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n</code></pre> <p>Creates a Some variant of Option containing a value</p> <ul> <li>@param SomeOption The value to wrap in Some</li> <li>@return An Option containing the provided value</li> </ul>"},{"location":"API/Option/Methods/#optionnone-constructor","title":"Option.None (Constructor)","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None()\n</code></pre> <p>Creates a None variant of Option containing no value</p> <ul> <li>@return An empty Option</li> </ul>"},{"location":"API/Option/Methods/#optionisoption-constructor","title":"Option.IsOption (Constructor)","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hell World\")\n\nprint(Option.IsOption(optA)) --&gt; true\n</code></pre> <p>Checks if a value is a valid Option instance</p> <ul> <li>@param option The value to check</li> <li>@return true if the value is an Option, false otherwise</li> </ul>"},{"location":"API/Option/Methods/#optionwrap-constructor","title":"Option.Wrap (Constructor)","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Wrap(\"Hell World\")\n</code></pre> <p>Wraps a nullable value in an Option</p> <p>If the value is nil, returns None; otherwise returns Some(value)</p> <ul> <li>@param value The nullable value to wrap   </li> <li>@return Option or Option"},{"location":"API/Option/Methods/#optiondeserialize-constructor","title":"Option.Deserialize (Constructor)","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Deserialize({\n    Tag = \"Some\",\n    Value = 10\n})\n</code></pre> <p>Deserializes data back into an Option Used to reconstruct Options from stored/transmitted data</p> <ul> <li>@param data Serialized Option data with Tag and Value fields</li> <li>@return The reconstructed Option</li> </ul>"},{"location":"API/Option/Methods/#optionissome","title":"Option:IsSome()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n\nprint(optA:IsSome()) --&gt; true\n</code></pre> <p>Checks if this Option contains a value (is Some variant)</p> <ul> <li>@return true if Option contains a value, false if None</li> </ul>"},{"location":"API/Option/Methods/#optionisnone","title":"Option:IsNone()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n\nprint(optA:IsNone()) --&gt; false\n</code></pre> <p>Checks if this Option is empty (is None variant)</p> <ul> <li>@return true if Option is None, false if it contains a value</li> </ul>"},{"location":"API/Option/Methods/#optionmatch","title":"Option:Match()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n\nlocal result = optA:Match({\n    Some = function(abc)\n        return #abc\n    end,\n    None = function()\n        --code\n    end,\n})\n</code></pre> <p>Pattern matching for Option - executes different code based on variant</p> <ul> <li>@param Options Table with Some and None callbacks</li> <li>@return Result of the executed callback</li> </ul>"},{"location":"API/Option/Methods/#optionassert","title":"Option:Assert()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None()\n\noptA:Assert(\"A value is required.\")\n</code></pre> <p>Asserts that the Option contains a value, throwing error if None</p> <ul> <li>@param error_message Custom error message to display if assertion fails</li> </ul>"},{"location":"API/Option/Methods/#optiongetor","title":"Option:GetOr()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None():GetOr(10)\n\nprint(optA) --&gt; 10 causing Option is none by default\n</code></pre> <p>Returns the contained value or a default if None</p> <ul> <li>@param value Default value to return if Option is None    </li> <li>@return The contained value or the default</li> </ul>"},{"location":"API/Option/Methods/#optionmap","title":"Option:Map()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World !\"):Map(function(value)\n    return #value\nend)\n\nprint(optA.Some) -- 13\nprint(optA.Tag) -- \"Some\"\n</code></pre> <p>Returns the contained value or a default if None</p> <ul> <li>@param value Default value to return if Option is None    </li> <li>@return The contained value or the default</li> </ul>"},{"location":"API/Option/Methods/#optionfilter","title":"Option:Filter()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World !\"):Filter(function(value)\n    if (#value &gt;= 13) then\n        return true\n    end\n    return false\nend)\n\nprint(optA.Some) --&gt; 13 causing the string is equal to 13 characters or more\nprint(optA.Tag) --&gt; Some\n</code></pre> <p>Filters the Option based on a predicate function</p> <p>Returns None if the predicate returns false or if already None</p> <ul> <li>@param callback Predicate function to test the value  </li> <li>@return Self if predicate passes, None otherwise</li> </ul>"},{"location":"API/Option/Methods/#optiongetorelse","title":"Option:GetOrElse()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None():GetOrElse(function()\n    return \"Hello World\"\nend)\n\nprint(optA) --&gt; \"Hello World\" -- (as optA is None, the function passed to GetOrElse is called and its result is returned)\n</code></pre> <p>Returns the contained value or computes a default using a callback</p> <ul> <li>@param callback Function to compute default value if None</li> <li>@return The contained value or computed default</li> </ul>"},{"location":"API/Option/Methods/#optionxor","title":"Option:XOR()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None()\nlocal optB = Option.Some(\"Hello World\")\nlocal result = optA:XOR(optB)\n\nprint(result.Some) --&gt; Hello World (Option.Some)\nprint(result.Tag) --&gt; Some\n</code></pre> <p>Exclusive OR operation between two Options</p> <p>Returns Some if exactly one Option is Some, None if both are Some or both are None</p> <ul> <li>@param OptionB The other Option to XOR with</li> <li>@return Result of XOR operation</li> </ul>"},{"location":"API/Option/Methods/#optionandthen","title":"Option:AndThen()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\"):AndThen(function(value)\n    return Option.Some(#value)\nend)\n\nprint(optA.Some) --&gt; 11\n</code></pre> <p>Chains Option operations - applies callback only if Some The callback must return another Option</p> <ul> <li>@param callback Function that takes the value and returns an Option</li> <li>@return Result of the callback or None</li> </ul>"},{"location":"API/Option/Methods/#optionexpect","title":"Option.Expect()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None()\n\noptA:Expect(\"optA must be Option.Some().\")\n</code></pre> <p>Unwraps the value with a custom panic message if None</p> <ul> <li>@param msg Error message to display if Option is None</li> <li>@return The contained value</li> <li>@error Throws if Option is None</li> </ul>"},{"location":"API/Option/Methods/#optionexpectnone","title":"Option.ExpectNone()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n\noptA:ExpectNone(\"optA must be Option.None().\")\n</code></pre> <p>Asserts that the Option is None, throwing error if Some</p> <ul> <li>@param msg Error message to display if Option contains a value</li> <li>@error Throws if Option is Some</li> </ul>"},{"location":"API/Option/Methods/#optionunwrap","title":"Option:UnWrap()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\"):UnWrap()\n\nprint(optA) --&gt; \"Hello World\"\n</code></pre> <p>Unwraps the contained value, panicking with default message if None</p> <ul> <li>@return The contained value</li> <li>@error Throws \"Called UnWrap() on None\" if Option is None</li> </ul>"},{"location":"API/Option/Methods/#optionunwrapor","title":"Option:UnWrapOr()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None():UnWrapOr(\"Hello World\")\n\nprint(optA) -- \"Hello World\"\n</code></pre> <p>Unwraps the value or returns a default if None; Alias for GetOr</p> <ul> <li>@param value Default value to return if None</li> <li>@return The contained value or default</li> </ul>"},{"location":"API/Option/Methods/#optionunwraporelse","title":"Option:UnWrapOrElse()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.None():UnWrapOrElse(function()\n    return \"Hello World\"\nend)\n\nprint(optA) -- \"Hello World\"\n</code></pre> <p>Unwraps the value or computes a default if None; Alias for GetOrElse</p> <ul> <li>@param callback Function to compute default if None</li> <li>@return The contained value or computed default</li> </ul>"},{"location":"API/Option/Methods/#optioncontains","title":"Option:Contains()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\nlocal containsNumber = optA:Contains(10)\n\nprint(containsNumber) --&gt; false\n</code></pre> <p>Checks if the Option contains a specific value</p> <ul> <li>@param value The value to check for</li> <li>@return true if Option contains the exact value, false otherwise</li> </ul>"},{"location":"API/Option/Methods/#optionserialize","title":"Option:Serialize()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\"):Serialize()\n\nprint(optA.Value) --&gt; \"Hello World\"\nprint(optA.Tag) --&gt; \"Some\"\n</code></pre> <p>Serializes the Option for storage or transmission</p> <ul> <li>@return Table with Tag and optional Value fields</li> </ul>"},{"location":"API/Option/Methods/#metamethods","title":"Metamethods","text":""},{"location":"API/Option/Methods/#__tostring","title":"__tostring()","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\n\nprint(optA) --&gt; Option(Hello World)\n</code></pre> <p>String representation of the Option - @return \"Option(value)\" for Some, \"Option(None)\" for None</p>"},{"location":"API/Option/Methods/#__eq","title":"__eq","text":"<pre><code>local Option = require(somewhere.Option)\n\nlocal optA = Option.Some(\"Hello World\")\nlocal optB = Option.Some(\"Hello World\")\n\nprint(optA == optB) --&gt; true\n</code></pre> <p>Equality comparison between two Options</p> <p>Two Options are equal if:</p> <ul> <li>Both are None, or</li> <li>Both are Some and contain equal values</li> </ul> <ul> <li>@param b The other Option to compare with</li> <li>@return true if Options are equal, false otherwise</li> </ul>"},{"location":"API/Option/Methods/#alias","title":"Alias","text":"<pre><code>-- Lowercase aliases for methods (alternative naming convention)\n-- These provide the same functionality with camelCase naming\nOptionComponent.Unwrap = OptionComponent.UnWrap\nOptionComponent.UnwrapOr = OptionComponent.UnWrapOr\nOptionComponent.getOr = OptionComponent.GetOr\nOptionComponent.getOrElse = OptionComponent.GetOrElse\nOptionComponent.expectNone = OptionComponent.ExpectNone\nOptionComponent.andThen = OptionComponent.AndThen\nOptionComponent.map = OptionComponent.Map\nOptionComponent.filter = OptionComponent.Filter\nOptionComponent.assert = OptionComponent.Assert\nOptionComponent.match = OptionComponent.Match\nOptionComponent.contains = OptionComponent.Contains\nOptionComponent.isNone = OptionComponent.IsNone\nOptionComponent.isSome = OptionComponent.IsSome\nOptionComponent.serialize = OptionComponent.Serialize\n\n-- OptionConstructor lowercase aliases\nOptionConstructor.isOption = OptionConstructor.IsOption\nOptionConstructor.deserialize = OptionConstructor.Deserialize\n</code></pre>"},{"location":"API/Socket/","title":"Overview","text":""},{"location":"API/Socket/#getting-started","title":"Getting Started","text":"<p>Socket, Provides a unified, type-safe API for client-server communication in Roblox</p> <p>Features  - buffer serialization for efficient network usage</p> <p>Note</p> <p>This module uses the <code>Buffer</code> module, which means that with each update of it, <code>Socket</code> will be re-uploaded.</p>"},{"location":"API/Socket/#version","title":"Version","text":""},{"location":"API/Socket/#socket-v131","title":"Socket V1.3.1","text":""},{"location":"API/Socket/#important","title":"Important","text":""},{"location":"API/Socket/#using-non-defined-string-length","title":"Using non-defined string length","text":"<p>For string data type that require more than 64 byte please use something like this :</p> <pre><code>local schema : Socket.BufferSchema = {\n    Value = {\n        Type = \"String\",\n        Length = 1024\n    } -- This will require 1024 bytes\n}\n</code></pre>"},{"location":"API/Socket/#padding-characters-if-len-is-not-respected","title":"Padding characters if len is not respected","text":"<p>When you use a <code>String</code> type regardless of size (A custom or String[Len]), if the size is not respected, for example if you use a <code>String8</code> and the string is less than 8 characters, special characters</p> <pre><code>string.char(31)\n</code></pre> <p>will be placed. Please note that these characters are automatically removed during buffer deserialization  so your data will NOT be impacted unless you put this character in the string itself.</p>"},{"location":"API/Socket/Advanced/","title":"Advanced","text":""},{"location":"API/Socket/Advanced/#getting-started","title":"Getting Started","text":"<p>Most stuff of the lastest version of <code>Socket</code> that impact the module itself will be here.</p>"},{"location":"API/Socket/Advanced/#extended-buildget-methods","title":"Extended Build/Get Methods","text":"<pre><code>--@Client\nSocketClient.GetRemote&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --&gt; equivalent to Socket.Client.Remote.get()\nSocketClient.GetFunction&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --&gt; equivalent to Socket.Client.Function.get()\nSocketClient.GetUnreliableRemote&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --&gt; equivalent to Socket.Client.UnreliableRemote.get()\n\nSocketClient.GetExtendedRemote&lt;T...&gt;(Configuration : extendedRemoteConfiguration) --&gt; [[\n--[[\n    local Remote = Socket.Client.GetExtendedRemote({\n        SocketName = \"HelloWorld\",\n        Schema = {Message = \"String8\"},\n        ConnectionCallback = function(values)\n            print(values)\n        end,\n    })\n    same as\n    local Remote = Socket.Client.Remote.get(\"HelloWorld\",{Message = \"String8\"})\n    Remote:Connect(func)\n]]\nSocket.Client.GetExtendedFunction&lt;T...&gt;(Configuration : extendedFunctionConfiguration) --&gt; equivalent but for RemoteFunction\nSocket.Client.GetExtendedUnreliableRemote&lt;T...&gt;(Configuration : extendedRemoteConfiguration) --&gt; equivalent but for UnreliableRemoteEvent\n\n--@Server\nSocketServer.BuildRemote&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --&gt; equivalent to Socket.Server.Remote.Create()\nSocketServer.BuildFunction&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --&gt; equivalent to Socket.Server.Function.Create()\nSocketServer.BuildUnreliableRemote&lt;T...&gt;(SocketName : string, Schema : Buffer.BufferSchema) --  equivalent to Socket.Server.UnreliableRemote.Create()\n\nSocketServer.BuildExtendedRemote&lt;T...&gt;(Configuration : extendedRemoteConfiguration) --&gt; [[\n--[[\n    local Remote = Socket.Server.BuildExtendedRemote({\n        SocketName = \"Test\",\n        Schema = {Money = \"Float64\"},\n        ConnectionCallback = function(player, valueSchema)\n            print(player, valueSchema)\n        end\n    })\n    same as\n    local Remote = Socket.Server.Remote.Create(\"Test\",{Money = \"Float64\"})\n    Remote:Connect(func)\n]]\n\nSocket.Server.BuildExtendedFunction&lt;T...&gt;(Configuration : extendedFunctionConfiguration) --&gt; equivalent but for RemoteFunction\nSocket.Server.BuildExtendedUnreliableRemote&lt;T...&gt;(Configuration : extendedRemoteConfiguration) --&gt; equivalent but for UnreliableRemoteEvent\n</code></pre>"},{"location":"API/Socket/Types/RemoteEvent/","title":"RemoteEvent","text":""},{"location":"API/Socket/Types/RemoteEvent/#getting-started","title":"Getting Started","text":"<p>All information for creating RemoteEvents with <code>Socket</code> will be here.</p>"},{"location":"API/Socket/Types/RemoteEvent/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n--I recommend to put ': Socket.BufferSchema' for intellisense\nlocal RemoteSchema : Socket.BufferSchema = {\n    Money = \"Float64\",\n}\n\n-- Create a new SocketRemote (server-side RemoteEvent wrapper)\n-- Parameters:\n--   \"Test\" - Unique name for this event endpoint\n--   Schema table - Defines expected data structure from clients\n--     Money: expects a 64-bit floating point number (double precision)\nlocal Remote = Socket.Server.Remote.Create(\"Test\",RemoteSchema)\n\n-- Set up a listener to handle events fired by clients\n-- The handler receives:\n--   player: Player who fired the event\n--   valueSchema: Deserialized data sent by client (validated against schema above)\nRemote:Connect(function(player, valueSchema)\n    -- Print received data for debugging/logging\n    -- Example output: [Player] {Money = 99.99}\n    print(player, valueSchema)\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n-- Find the existing RemoteEvent created by the server\n-- Parameters:\n--   \"Test\" - Name of the RemoteEvent (must match server's name)\n--   Schema table - Defines expected data structure for this event\n--     Money: expects a 64-bit floating point number (double precision)\nlocal Remote = Socket.Client.Remote.Find(\"Test\",{\n    Money = \"Float64\";  -- Must match schema defined on server\n})\n\n-- Fire an event to the server with data\n-- Parameter:\n--   {Money = 15.155} - Data to send to server (must match schema above)\n-- Note: This is \"fire-and-forget\" - no response is expected or returned\nRemote:Fire({\n    Money = 15.155  -- Send money value to server\n})\n</code></pre> <p>This will create a Buffer Networking using RemoteEvent</p>"},{"location":"API/Socket/Types/RemoteEvent/#methods","title":"Methods","text":""},{"location":"API/Socket/Types/RemoteEvent/#server","title":"Server","text":""},{"location":"API/Socket/Types/RemoteEvent/#remotecreate","title":"Remote.Create()","text":"<p><code>Remote.Create(Name,Schema)</code></p> <pre><code>local Remote = Socket.Server.Remote.Create(\"Test\",RemoteSchema)\nor\nlocal Remote = Socket.Server.BuildRemote(\"Test\",RemoteSchema)\n</code></pre> <p>Creates a new RemoteEvent and wraps it in a SocketRemote component</p> <ul> <li>@param SocketName: Unique name for the RemoteEvent</li> <li>@param Schema: Buffer schema for data validation/serialization</li> <li>@return: New SocketRemote component</li> </ul>"},{"location":"API/Socket/Types/RemoteEvent/#remotefireclient","title":"Remote.FireClient()","text":"<p><code>Remote.FireClient(Player,...)</code></p> <p>Fires data to a specific client through the RemoteEvent</p> <ul> <li>@param Player : Target player to send data to</li> <li>@param values : Data to send (must match Schema structure)</li> </ul> <p>Warning</p> <p>Please see the examples for firing data to the server/client.</p>"},{"location":"API/Socket/Types/RemoteEvent/#remotefireall","title":"Remote.FireAll()","text":"<p><code>Remote.FireAll(...)</code></p> <p>Fires data to all clients through the RemoteEvent</p> <p>@param values : Data to send to all clients (must match Schema structure)</p> <p>Warning</p> <p>Please see the examples for firing data to the server/client.</p>"},{"location":"API/Socket/Types/RemoteEvent/#remoteconnect","title":"Remote.Connect()","text":"<p><code>Remote.Connect((Player : Player,ValueSchema : Buffer.BufferSchemaValue) -&gt; ())</code></p> <p>Connects a callback to handle events from clients</p> <ul> <li>@param callback: Function to process client events</li> </ul>"},{"location":"API/Socket/Types/RemoteEvent/#remoteclearconnections","title":"Remote.ClearConnections()","text":"<p><code>Remote.ClearConnections()</code></p> <p>Disconnects all active connections</p>"},{"location":"API/Socket/Types/RemoteEvent/#remotedestroy","title":"Remote.Destroy()","text":"<p><code>Remote.Destroy()</code></p> <p>Destroys the component and its RemoteEvent</p>"},{"location":"API/Socket/Types/RemoteEvent/#client","title":"Client","text":""},{"location":"API/Socket/Types/RemoteEvent/#remotefind","title":"Remote.Find()","text":"<p><code>Remote.Find(Name : string,Schema)</code></p> <pre><code>-- Find the existing RemoteEvent created by the server\n-- Parameters:\n--   \"Test\" - Name of the RemoteEvent (must match server's name)\n--   Schema table - Defines expected data structure for this event\nlocal Remote = Socket.Client.Remote.Find(\"Test\",RemoteSchema)\n</code></pre> <p>Finds an existing RemoteEvent created by the server and wraps it</p> <ul> <li>@param SocketName: Name of the RemoteEvent to find</li> <li>@param Schema: Buffer schema for data validation/serialization</li> <li>@return: SocketRemote component wrapping the RemoteEvent</li> </ul>"},{"location":"API/Socket/Types/RemoteEvent/#remotefire","title":"Remote.Fire()","text":"<p><code>Remote.Fire(ValueSchema)</code></p> <p>Fires data to the server through the RemoteEvent</p> <ul> <li>@param values : Data to send (must match Schema structure)</li> </ul> <p>Warning</p> <p>Please see the examples for firing data to the server/client.</p>"},{"location":"API/Socket/Types/RemoteEvent/#remoteconnect_1","title":"Remote.Connect()","text":"<p><code>Remote.Connect(callback : (values) -&gt; ())</code></p> <pre><code>-- Set up a listener to handle events fired by the server\n-- The handler receives:\n--   valueSchema: Deserialized data sent by client (validated against schema above)\nRemote:Connect(function(valueSchema)\n    -- Print received data for debugging/logging\n    print(player, valueSchema)\nend)\n</code></pre> <p>Connects a callback to handle events from the server</p> <ul> <li>@param callback: Function to process server events</li> </ul>"},{"location":"API/Socket/Types/RemoteEvent/#remoteclearconnections_1","title":"Remote.ClearConnections()","text":"<p><code>Remote.ClearConnections()</code></p> <p>Disconnects all active connections</p>"},{"location":"API/Socket/Types/RemoteEvent/#remotedestroy_1","title":"Remote.Destroy()","text":"<p><code>Remote.Destroy()</code></p> <p>Destroys the component and its RemoteEvent</p>"},{"location":"API/Socket/Types/RemoteEvent/#server-alias","title":"Server alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketRemoteConstructor.create = SocketRemoteConstructor.Create\nSocketRemoteConstructor.new = SocketRemoteConstructor.Create\nSocketRemoteConstructor.New = SocketRemoteConstructor.Create\n\nSocketRemote.fireClient = SocketRemote.FireClient\nSocketRemote.fireAll = SocketRemote.FireAll\nSocketRemote.connect = SocketRemote.Connect\nSocketRemote.Disconnects = SocketRemote.ClearConnections\nSocketRemote.disconnects = SocketRemote.ClearConnections\nSocketRemote.destroy = SocketRemote.Destroy\nSocketRemote.Clean = SocketRemote.Destroy\nSocketRemote.clean = SocketRemote.Destroy\n</code></pre>"},{"location":"API/Socket/Types/RemoteEvent/#client-alias","title":"Client alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketRemoteConstructor.find = SocketRemoteConstructor.Find\nSocketRemoteConstructor.get = SocketRemoteConstructor.Find\nSocketRemoteConstructor.Get = SocketRemoteConstructor.Find\n\nSocketRemote.fire = SocketRemote.Fire\nSocketRemote.connect = SocketRemote.Connect\nSocketRemote.Disconnects = SocketRemote.ClearConnections\nSocketRemote.disconnects = SocketRemote.ClearConnections\nSocketRemote.destroy = SocketRemote.Destroy\nSocketRemote.Clean = SocketRemote.Destroy\nSocketRemote.clean = SocketRemote.Destroy\n</code></pre>"},{"location":"API/Socket/Types/RemoteFunction/","title":"RemoteFunction","text":""},{"location":"API/Socket/Types/RemoteFunction/#getting-started","title":"Getting Started","text":"<p>To properly handle remote functions with <code>Socket</code>, everything will be explained here.</p>"},{"location":"API/Socket/Types/RemoteFunction/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n--I recommend to put ': Socket.BufferSchema' for intellisense\nlocal FunctionSchema : Socket.BufferSchema = {\n    Message = \"String8\";  -- Client must send a table with {Message = \"some string\"}\n}\n\n-- Create a new SocketFunction (server-side RemoteFunction wrapper)\n-- Parameters:\n--   \"TestFunc\" - Unique name for this function endpoint\n--   Schema table - Defines expected data structure from client\n--     Message: expects a string (up to 8 bytes/chars, based on Buffer implementation)\nlocal Function = Socket.Server.Function.Create(\"TestFunc\",FunctionSchema)\n\n-- Set up the server handler that will be called when a client invokes this function\n-- The handler receives:\n--   player: Player who invoked the function\n--   invokeValueSchema: Deserialized data sent by client (validated against schema above)\nFunction:InsertHandle(function(player, invokeValueSchema)\n    -- Define response schema - what data structure we'll send back to client\n    local schema : Socket.BufferSchema = {\n        Value = \"I8\"  -- Will send back an integer (8-bit)\n    }\n    -- Define actual response values matching the schema\n    local value = {Value = 18}  -- Sends {Value = 18} back to client\n    -- Return both schema and value - they'll be serialized and sent to client\n    return schema, value\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n-- Find the existing RemoteFunction created by the server\n-- Parameters:\n--   \"TestFunc\" - Name of the RemoteFunction (must match server's name)\n--   Schema table - Defines expected data structure for this function\n--     Message: expects a string (up to 8 bytes/chars, based on Buffer implementation)\nlocal Remote = Socket.Client.Function.Find(\"TestFunc\",{\n    Message = \"String8\",  -- Must match schema defined on server\n})\n\n-- Invoke the server function and wait for response\n-- Parameters:\n--   {Message = \"Hello\"} - Data to send to server (must match input schema)\n--   {Value = \"I8\"} - Schema defining expected response structure from server\n-- Returns: Deserialized response table or nil if timeout/error\nlocal result = Remote:Fire({Message = \"Hello\"},{Value = \"I8\"})\n\n-- Print the result received from server\n-- Expected output: {Value = 18} (based on server example that returns {Value = 18})\nprint(result)\n</code></pre> <p>This will create a Buffer Networking using RemoteFunction</p>"},{"location":"API/Socket/Types/RemoteFunction/#methods","title":"Methods","text":""},{"location":"API/Socket/Types/RemoteFunction/#server","title":"Server","text":""},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioncreate","title":"RemoteFunction.Create()","text":"<p><code>RemoteFunction.Create(Name,Schema)</code></p> <pre><code>local Function = Socket.Server.Function.Create(\"TestFunc\",FunctionSchema)\n</code></pre> <p>Creates a new RemoteFunction and wraps it in a SocketFunction component</p> <ul> <li>@param SocketName: Unique name for the RemoteFunction</li> <li>@param InvokeSchema: Buffer schema for validating/deserializing client data</li> <li>@return: New SocketFunction component</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioninserthandle","title":"RemoteFunction.InsertHandle()","text":"<p><code>RemoteFunction.InsertHandle(callback : (Player,Values) -&gt; (Buffer.BufferSchema,Buffer.BufferSchemaValue))</code></p> <p>Sets up handler for client invokes (OnServerInvoke)</p> <ul> <li>@param callback: Function to process client requests</li> <li>@return: Response schema and value to send back to client</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctionremovehandler","title":"RemoteFunction.RemoveHandler()","text":"<p><code>RemoteFunction.RemoveHandler()</code></p> <p>Remove the current listener of OnServerInvoke</p>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioninvoke","title":"RemoteFunction.Invoke()","text":"<p><code>RemoteFunction.Invoke(Player,...)</code></p> <pre><code>--@Server\n\nlocal age = Function:Invoke(game.Players:GetPlayers()[1],{\n    Message = \"Anything\" -- 8 characters 'String8' , see the examples \n},Schema)\n\nwarn(age) --&gt; the random generated number\n\n--@Client\n\n--@OnClientInvoke Listener\nRemote:InsertHandle(function(invokeValueSchema)\n    local ageSchema : Socket.BufferSchema = {\n        Age = \"U8\" -- unsigned int 8-bit\n    }\n    local values = {\n        Age = math.random(0,255) % 255 + 1 --&gt; random number (0-255)\n    }\n    return ageSchema,values --&gt; the order is really important.\nend)\n</code></pre> <p>Yield Invokes a specific client with buffer-serialized data</p> <ul> <li>@param Player: Target player to invoke</li> <li>@param values: Data to send (must match InvokeSchema)</li> <li>@param ReturnSchema: Schema for deserializing client's response</li> <li>@return: Deserialized response from client, or nil on timeout/error</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioninvokeall","title":"RemoteFunction.InvokeAll()","text":"<p><code>RemoteFunction.InvokeAll(...)</code></p> <p>Yield Invokes all clients with buffer-serialized data</p> <p>@param values : Data to send to all clients @param ReturnSchema : Schema for deserializing client responses</p> <p>@return : Table of deserialized responses from clients, or nil on timeout</p> <p>Info</p> <p>See exemple above to invoke data with RemoteFunction</p>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctionsettimeout","title":"RemoteFunction.SetTimeout()","text":"<pre><code>RemoteFunction.SetTimeout(n : number)\n</code></pre> <p>Sets timeout duration for InvokeClient operations</p> <ul> <li>@param value: Timeout in seconds (converted to positive)</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctiondestroy","title":"RemoteFunction.Destroy()","text":"<p><code>RemoteFunction.Destroy()</code></p> <p>Destroys the component and its RemoteFunction</p>"},{"location":"API/Socket/Types/RemoteFunction/#client","title":"Client","text":""},{"location":"API/Socket/Types/RemoteFunction/#remotefunctionfind","title":"RemoteFunction.Find()","text":"<p><code>RemoteFunction.Find(Name,Schema)</code></p> <p>Finds an existing RemoteFunction created by the server and wraps it</p> <ul> <li>@param SocketName: Name of the RemoteFunction to find</li> <li>@param InvokeSchema: Buffer schema for data validation/serialization</li> <li>@return: SocketFunction component wrapping the RemoteFunction</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioninvokeserver","title":"RemoteFunction.InvokeServer()","text":"<p>Warning</p> <p>See the Examples to see the code example or just go to FireClient</p> <p>Invokes the server's OnServerInvoke handler with buffer-serialized data</p> <ul> <li>@param InvokeValueSchema: Data to send (must match InvokeSchema structure)</li> <li>@param ReturnSchema: Schema for deserializing server's response</li> <li>@return: Deserialized response from server, or nil on timeout/error</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctioninserthandle_1","title":"RemoteFunction.InsertHandle()","text":"<p><code>RemoteFunction.InsertHandle(callback : (Values) -&gt; (Buffer.BufferSchema,Buffer.BufferSchemaValue))</code></p> <p>Sets up handler for when server invokes this client</p> <ul> <li>Only used if server calls InvokeClient on this RemoteFunction</li> <li>@param callback: Function to handle server invokes</li> <li>@return: Response schema and value to send back to server</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctionremovehandler_1","title":"RemoteFunction.RemoveHandler()","text":"<p><code>RemoteFunction.RemoveHandler()</code></p> <p>Remove the current listener of OnClientInvoke</p>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctionsettimeout_1","title":"RemoteFunction.SetTimeout()","text":"<pre><code>RemoteFunction.SetTimeout(n : number)\n</code></pre> <p>Configures timeout for InvokeServer operations</p> <ul> <li>@param value: Timeout in seconds (converted to positive)</li> </ul>"},{"location":"API/Socket/Types/RemoteFunction/#remotefunctiondestroy_1","title":"RemoteFunction.Destroy()","text":"<p><code>RemoteFunction.Destroy()</code></p> <p>Cleans up the component (does not destroy the RemoteFunction)</p>"},{"location":"API/Socket/Types/RemoteFunction/#server-alias","title":"Server alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketFunctionConstructor.create = SocketFunctionConstructor.Create\nSocketFunctionConstructor.new = SocketFunctionConstructor.Create\nSocketFunctionConstructor.New = SocketFunctionConstructor.Create\n\nSocketFunction.fireClient = SocketFunction.Invoke\nSocketFunction.InvokeClient = SocketFunction.Invoke\nSocketFunction.invokeClient = SocketFunction.Invoke\nSocketFunction.invokeAll = SocketFunction.InvokeAll\nSocketFunction.insert = SocketFunction.InsertHandle\nSocketFunction.Insert = SocketFunction.InsertHandle\nSocketFunction.setTimeout = SocketFunction.SetTimeout\nSocketFunction.Clean = SocketFunction.Destroy\nSocketFunction.clean = SocketFunction.Destroy\nSocketFunction.destroy = SocketFunction.Destroy\nSocketFunction.removeHandler = SocketFunction.RemoveHandler\n</code></pre>"},{"location":"API/Socket/Types/RemoteFunction/#client-alias","title":"Client alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketFunctionConstructor.find = SocketFunctionConstructor.Find\nSocketFunctionConstructor.get = SocketFunctionConstructor.Find\nSocketFunctionConstructor.Get = SocketFunctionConstructor.Find\n\nSocketFunction.fire = SocketFunction.Fire\nSocketFunction.Invoke = SocketFunction.Fire\nSocketFunction.invoke = SocketFunction.Fire\nSocketFunction.insert = SocketFunction.InsertHandle\nSocketFunction.Insert = SocketFunction.InsertHandle\nSocketFunction.setTimeout = SocketFunction.SetTimeout\nSocketFunction.Clean = SocketFunction.Destroy\nSocketFunction.clean = SocketFunction.Destroy\nSocketFunction.destroy = SocketFunction.Destroy\nSocketFunction.removeHandler = SocketFunction.RemoveHandler\n</code></pre>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/","title":"UnreliableRemoteEvent","text":""},{"location":"API/Socket/Types/UnreliableRemoteEvent/#getting-started","title":"Getting Started","text":"<p>All information for creating UnreliableRemoteEvents with <code>Socket</code> will be here.</p> <p>Note</p> <p>UnreliableRemoteEvents may drop packets and don't guarantee delivery order and has a 1000 byte limit.</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#examples","title":"Examples","text":"<ul> <li>@Server</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n--I recommend to put ': Socket.BufferSchema' for intellisense\nlocal UnreliableRemoteSchema : Socket.BufferSchema = {\n    Money = \"Float64\",\n}\n\n-- Create a new SocketUnreliableRemote (server-side UnreliableRemoteEvent wrapper)\n-- Parameters:\n--   \"Test\" - Unique name for this event endpoint\n--   Schema table - Defines expected data structure from clients\n--     Money: expects a 64-bit floating point number (double precision)\nlocal UnreliableRemote = Socket.Server.UnreliableRemote.Create(\"Test\",UnreliableRemoteSchema)\n\n-- Set up a listener to handle events fired by clients\n-- The handler receives:\n--   player: Player who fired the event\n--   valueSchema: Deserialized data sent by client (validated against schema above)\nUnreliableRemote:Connect(function(player, valueSchema)\n    -- Print received data for debugging/logging\n    -- Example output: [Player] {Money = 99.99}\n    print(player, valueSchema)\nend)\n</code></pre> <ul> <li>@Client</li> </ul> <pre><code>local Socket = require(somewhere.Socket)\n\n-- Find the existing UnreliableRemoteEvent created by the server\n-- Parameters:\n--   \"Test\" - Name of the UnreliableRemoteEvent (must match server's name)\n--   Schema table - Defines expected data structure for this event\n--     Money: expects a 64-bit floating point number (double precision)\nlocal UnreliableRemote = Socket.Client.UnreliableRemote.Find(\"Test\",{\n    Money = \"Float64\";  -- Must match schema defined on server\n})\n\n-- Fire an event to the server with data\n-- Parameter:\n--   {Money = 15.155} - Data to send to server (must match schema above)\n-- Note: This is \"fire-and-forget\" - no response is expected or returned\nUnreliableRemote:Fire({\n    Money = 15.155  -- Send money value to server\n})\n</code></pre> <p>This will create a Buffer Networking using UnreliableRemoteEvent</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#methods","title":"Methods","text":""},{"location":"API/Socket/Types/UnreliableRemoteEvent/#server","title":"Server","text":""},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotecreate","title":"UnreliableRemote.Create()","text":"<p><code>UnreliableRemote.Create(Name,Schema)</code></p> <pre><code>local UnreliableRemote = Socket.Server.UnreliableRemote.Create(\"Test\",UnreliableRemoteSchema)\nor\nlocal UnreliableRemote = Socket.Server.BuildUnreliableRemote(\"Test\",UnreliableRemoteSchema)\n</code></pre> <p>Creates a new UnreliableRemoteEvent and wraps it in a SocketUnreliableRemote component</p> <ul> <li>@param SocketName: Unique name for the UnreliableRemoteEvent</li> <li>@param Schema: Buffer schema for data validation/serialization</li> <li>@return: New SocketUnreliableRemote component</li> </ul>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotefireclient","title":"UnreliableRemote.FireClient()","text":"<p><code>UnreliableRemote.FireClient(Player,...)</code></p> <p>Fires data to a specific client through the UnreliableRemoteEvent</p> <ul> <li>Note: Delivery is not guaranteed and packets may be dropped</li> <li>@param Player: Target player to send data to</li> <li>@param values: Data to send (must match Schema structure)</li> </ul> <p>Warning</p> <p>Please see the examples for firing data to the server/client.</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotefireall","title":"UnreliableRemote.FireAll()","text":"<p><code>UnreliableRemote.FireAll(...)</code></p> <p>Fires data to a specific client through the UnreliableRemoteEvent</p> <ul> <li> <p>Note : Delivery is not guaranteed - use for non-critical updates</p> </li> <li> <p>@param Player : Target player to send data to</p> </li> <li>@param values : Data to send (must match Schema structure)</li> </ul>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremoteconnect","title":"UnreliableRemote.Connect()","text":"<p><code>UnreliableRemote.Connect((Player : Player,values : Buffer.BufferSchemaValue) -&gt; ())</code></p> <p>Connects a callback to handle events from clients</p> <ul> <li>Note: Events may arrive out of order or be dropped entirely</li> <li>@param callback: Function to process client events</li> </ul>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremoteclearconnections","title":"UnreliableRemote.ClearConnections()","text":"<p><code>UnreliableRemote.ClearConnections()</code></p> <p>Disconnects all active connections</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotedestroy","title":"UnreliableRemote.Destroy()","text":"<p><code>UnreliableRemote.Destroy()</code></p> <p>Destroys the component and its UnreliableRemoteEvent</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#client","title":"Client","text":""},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotefind","title":"UnreliableRemote.Find()","text":"<p><code>UnreliableRemote.Find(Name : string,Schema)</code></p> <pre><code>-- Find the existing UnreliableRemoteEvent created by the server\n-- Parameters:\n--   \"Test\" - Name of the UnreliableRemoteEvent (must match server's name)\n--   Schema table - Defines expected data structure for this event\nlocal UnreliableRemote = Socket.Client.UnreliableRemote.Find(\"Test\",UnreliableRemoteSchema)\n</code></pre> <p>Finds an existing UnreliableRemoteEvent created by the server and wraps it</p> <ul> <li>@param SocketName: Name of the UnreliableRemoteEvent to find</li> <li>@param Schema: Buffer schema for data validation/serialization</li> <li>@return: SocketUnreliableRemote component wrapping the UnreliableRemoteEvent</li> </ul>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotefire","title":"UnreliableRemote.Fire()","text":"<p><code>UnreliableRemote.Fire(...)</code></p> <p>Fires data to the server through the UnreliableRemoteEvent</p> <ul> <li>Note: Delivery is not guaranteed and packets may be dropped</li> <li>@param values: Data to send (must match Schema structure)</li> </ul> <p>Warning</p> <p>Please see the examples for firing data to the server/client.</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremoteconnect_1","title":"UnreliableRemote.Connect()","text":"<p><code>UnreliableRemote.Connect(callback : (values) -&gt; ())</code></p> <pre><code>-- Set up a listener to handle events fired by the server\n-- The handler receives:\n--   valueSchema: Deserialized data sent by client (validated against schema above)\nUnreliableRemote:Connect(function(valueSchema)\n    -- Print received data for debugging/logging\n    print(player, valueSchema)\nend)\n</code></pre> <p>Connects a callback to handle events from the server</p> <ul> <li>Note: Events may arrive out of order or be dropped entirely</li> <li>@param callback: Function to process server events</li> </ul>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremoteclearconnections_1","title":"UnreliableRemote.ClearConnections()","text":"<p><code>UnreliableRemote.ClearConnections()</code></p> <p>Disconnects all active connections</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#unreliableremotedestroy_1","title":"UnreliableRemote.Destroy()","text":"<p><code>UnreliableRemote.Destroy()</code></p> <p>Destroys the component and its UnreliableRemoteEvent</p>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#server-alias","title":"Server alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketUnreliableRemoteConstructor.create = SocketUnreliableRemoteConstructor.Create\nSocketUnreliableRemoteConstructor.new = SocketUnreliableRemoteConstructor.Create\nSocketUnreliableRemoteConstructor.New = SocketUnreliableRemoteConstructor.Create\n\nSocketUnreliableRemote.fireClient = SocketUnreliableRemote.FireClient\nSocketUnreliableRemote.fireAll = SocketUnreliableRemote.FireAll\nSocketUnreliableRemote.connect = SocketUnreliableRemote.Connect\nSocketUnreliableRemote.Disconnects = SocketUnreliableRemote.ClearConnections\nSocketUnreliableRemote.disconnects = SocketUnreliableRemote.ClearConnections\nSocketUnreliableRemote.destroy = SocketUnreliableRemote.Destroy\nSocketUnreliableRemote.Clean = SocketUnreliableRemote.Destroy\nSocketUnreliableRemote.clean = SocketUnreliableRemote.Destroy\n</code></pre>"},{"location":"API/Socket/Types/UnreliableRemoteEvent/#client-alias","title":"Client alias","text":"<pre><code>-- Aliases for different naming preferences\nSocketUnreliableRemoteConstructor.find = SocketUnreliableRemoteConstructor.Find\nSocketUnreliableRemoteConstructor.get = SocketUnreliableRemoteConstructor.Find\nSocketUnreliableRemoteConstructor.Get = SocketUnreliableRemoteConstructor.Find\n\nSocketUnreliableRemote.fire = SocketUnreliableRemote.Fire\nSocketUnreliableRemote.connect = SocketUnreliableRemote.Connect\nSocketUnreliableRemote.Disconnects = SocketUnreliableRemote.ClearConnections\nSocketUnreliableRemote.disconnects = SocketUnreliableRemote.ClearConnections\nSocketUnreliableRemote.destroy = SocketUnreliableRemote.Destroy\nSocketUnreliableRemote.Clean = SocketUnreliableRemote.Destroy\nSocketUnreliableRemote.clean = SocketUnreliableRemote.Destroy\n</code></pre>"},{"location":"API/Task/","title":"Overview","text":""},{"location":"API/Task/#getting-started","title":"Getting Started","text":"<p>Task: A class for managing and cleaning up tasks and resources.</p> <p>Note</p> <p>See 'Collect' module for a better garbage collection module.</p>"},{"location":"API/Task/#version","title":"Version","text":""},{"location":"API/Task/#task-v11","title":"Task V1.1","text":""},{"location":"API/Task/Methods/","title":"Methods","text":""},{"location":"API/Task/Methods/#getting-started","title":"Getting Started","text":"<p>All functions for the Task module will be here.</p>"},{"location":"API/Task/Methods/#methods","title":"Methods","text":""},{"location":"API/Task/Methods/#taskistask","title":"Task.IsTask()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\nprint(garbage:IsTask())  --&gt; true\nprint(Task.IsTask(garbage))  --&gt; true\n</code></pre> <p>Validates if an object is a Task instance</p> <ul> <li>@param self - The object to check</li> <li>@return boolean - True if it's a valid Task</li> </ul>"},{"location":"API/Task/Methods/#tasknew","title":"Task.new()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n</code></pre> <p>Constructor: Creates a new Task instance</p> <ul> <li>return Task - A new Task object with unique ID and empty task list</li> </ul>"},{"location":"API/Task/Methods/#taskaddpromise","title":"Task.AddPromise()","text":"<p>Promise V4</p> <p>Only compatible with the promise library, version 4.</p> <pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\ngarbage:Add(your_promise)\n</code></pre> <p>Adds a Promise to the task list and automatically removes it when resolved</p> <ul> <li>@param self - The Task instance</li> <li>@param _promise - The Promise to add</li> </ul>"},{"location":"API/Task/Methods/#taskadd","title":"Task.Add()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\ngarbage:Add(workspace.Baseplate)\n</code></pre> <p>Adds any supported task type to be managed</p> <ul> <li>@param self - The Task instance</li> <li>@param _task - The task to add (connection, instance, function, etc.)</li> </ul>"},{"location":"API/Task/Methods/#taskgettaskatindex","title":"Task.GetTaskAtIndex()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\ngarbage:Add(workspace.Baseplate)\n\n--later in your code\n\nlocal baseplate : Instance = garbage:GetTaskAtIndex(1)\n</code></pre> <p>Retrieves a task at a specific index (1-based, clamped to valid range)</p> <ul> <li>@param self - The Task instance</li> <li>@param index - The index to retrieve</li> <li>@return any - The task at the given index</li> </ul>"},{"location":"API/Task/Methods/#taskexecute","title":"Task.Execute()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\ngarbage:Add(function()\n    print(\"saved\")\nend)\n\n--later in your code\n\nlocal fn : () -&gt; () = garbage:GetTaskAtIndex(1)\n\nfn() --&gt; print \"saved\"\n</code></pre> <p>Executes a function and returns its result Utility method for running code within the Task context</p> <ul> <li>@param self - The Task instance</li> <li>@param callback - The function to execute</li> <li>@return any - The function's return value</li> </ul>"},{"location":"API/Task/Methods/#taskdestroy","title":"Task.Destroy()","text":"<pre><code>local Task = require(somewhere.Task)\n\nlocal garbage = Task.new()\n\ngarbage:Add(function()\n    print(\"saved\")\nend)\n\n--later in your code\n\ngarbage:Destroy() --&gt; will print \"saved\" cause is a clean up function\n</code></pre> <p>Main cleanup method - destroys all managed tasks and the Task instance itself</p> <ul> <li>@param self - The Task instance to destroy</li> </ul>"},{"location":"API/Task/Methods/#alias","title":"Alias","text":"<pre><code>-- Alias methods for flexibility and compatibility with different naming conventions\n_task_.clean = _task_.Destroy\n_task_.Clean = _task_.Destroy\n_task_.Disconnect = _task_.Destroy\n_task_.destroy = _task_.Destroy\n_task_.execute = _task_.Execute\n_task_.add = _task_.Add\n_task_.addPromise = _task_.AddPromise\n_task_.getTaskAtIndex =  _task_.GetTaskAtIndex\n_task_.isTask = _task_.IsTask\n</code></pre>"},{"location":"API/UserInput/","title":"Overview","text":""},{"location":"API/UserInput/#getting-started","title":"Getting Started","text":"<p>A comprehensive input handling system that provides unified interface for keyboard, gamepad, and mouse input with dynamic switching capabilities.</p>"},{"location":"API/UserInput/#version","title":"Version","text":""},{"location":"API/UserInput/#userinput-v14","title":"UserInput V1.4","text":""},{"location":"API/UserInput/#inputtype","title":"InputType","text":"<p> Gamepad</p> <p> Keyboard</p> <p> Mouse</p>"},{"location":"API/UserInput/Gamepad/","title":"Gamepad","text":""},{"location":"API/UserInput/Gamepad/#getting-started","title":"Getting Started","text":"<p>For gamepad buttons, you need to set <code>InputType</code> to <code>Gamepad</code>, then you can use all gamepad buttons.</p>"},{"location":"API/UserInput/Gamepad/#gamepad-object","title":"Gamepad Object","text":"<pre><code>local UserInput = require(somewhere.UserInput)\n\nlocal myGamepadConfiguration = UserInput.new({\n    InputType = \"Gamepad\",\n    Keys = {}\n})\n\n--listening to key pressed\nmyGamepadConfiguration:Pressed(function(key)\n    print(key)\nend)\n\nmyGamepadConfiguration:AddKey(Enum.KeyCode.ButtonA) -- or you can do {Enum.KeyCode.ButtonA,...} or \"ButtonA\"\n</code></pre> <p>This creates a Gamepad Object. You can change the type with <code>ChangeInputType</code>.</p>"},{"location":"API/UserInput/Keyboard/","title":"Keyboard","text":""},{"location":"API/UserInput/Keyboard/#getting-started","title":"Getting Started","text":"<p>For keyboard keys, you need to set <code>InputType</code> to <code>Keyboard</code>, then you can use all keyboard keys.</p>"},{"location":"API/UserInput/Keyboard/#keyboard-object","title":"Keyboard Object","text":"<pre><code>local UserInput = require(somewhere.UserInput)\n\n--[[\n    Using a empty configuration will resume to :\n    {\n        InputType = \"Keyboard\",\n        Keys = {},\n    }\n]]\nlocal myKeyboardConfiguration = UserInput.new()\n\n--listening to key pressed\nmyKeyboardConfiguration:Pressed(function(key)\n    print(key)\nend)\n\nmyKeyboardConfiguration:AddKey(Enum.KeyCode.E) -- or you can do {Enum.KeyCode.E,...} or \"E\"\n</code></pre> <p>This creates a Keyboard Object. You can change the type with <code>ChangeInputType</code>.</p>"},{"location":"API/UserInput/Methods/","title":"Methods","text":""},{"location":"API/UserInput/Methods/#getting-started","title":"Getting Started","text":"<p>This page shows all the functions of UserInput as well as functions specifically for the mouse.</p>"},{"location":"API/UserInput/Methods/#methods","title":"Methods","text":""},{"location":"API/UserInput/Methods/#userinputnew-constructor","title":"UserInput.new (Constructor)","text":"<p><code>new(config: UserInputConfiguration): UserInputComponent</code></p> <p>Creates a new UserInput component instance.</p> <p>Parameters config: Configuration object with the following properties:</p> <p><code>Keys: {Enum.KeyCode | Enum.UserInputType | string} - Array of keys to register</code></p> <p><code>InputType: \"Gamepad\" | \"Keyboard\" | \"Mouse\" - Initial input type</code></p>"},{"location":"API/UserInput/Methods/#userinputpressed","title":"UserInput:Pressed","text":"<p><code>Pressed(callback : (Enum.KeyCode | Enum.UserInputType)) -&gt; SignalConnection</code></p> <p>Public method to connect a callback to the key pressed event</p> <ul> <li>@param callback: Function that will be called when a registered key is pressed</li> <li>@return: SignalConnection that can be used to disconnect the callback</li> </ul>"},{"location":"API/UserInput/Methods/#userinputreleased","title":"UserInput:Released","text":"<p><code>Released(callback : (Enum.KeyCode | Enum.UserInputType)) -&gt; SignalConnection</code></p> <p>Public method to connect a callback to the key released event</p> <ul> <li>@param callback: Function that will be called when a registered key is released</li> <li>@return: SignalConnection that can be used to disconnect the callback</li> </ul>"},{"location":"API/UserInput/Methods/#userinputobserve","title":"UserInput:Observe","text":"<p><code>Observe(callback : (\"Gamepad\" | \"MouseKeyboard\" | \"Touch\")) -&gt; () -&gt; ()</code></p> <p>Observe changes in the user's preferred input method</p> <ul> <li>@param callback: Function called when input type changes (Gamepad, MouseKeyboard, or Touch)</li> <li>@return: Cleanup function to stop observing</li> </ul>"},{"location":"API/UserInput/Methods/#userinputgetinputtype","title":"UserInput:GetInputType","text":"<p><code>GetInputType() -&gt;  \"Gamepad\" | \"MouseKeyboard\" | \"Touch\"</code></p> <p>Returns the current input type</p> <ul> <li>@return: \"Gamepad\" | \"MouseKeyboard\" | \"Touch\" - Current input type</li> </ul>"},{"location":"API/UserInput/Methods/#userinputchangeinputtype","title":"UserInput:ChangeInputType","text":"<p><code>ChangeInputType(\"Gamepad\" | \"Keyboard\" | \"Mouse\",Keys : {Enum.KeyCode | Enum.UserInputType | string}</code></p> <p>Dynamically change the input type between Gamepad and Keyboard or Mouse This will clear all registered keys and recreate the input handlers</p> <p>Note</p> <ul> <li> <p>Pressed and Release connection don't need to be reconnected.</p> </li> <li> <p>You dont need to pass an array of keys.</p> </li> </ul>"},{"location":"API/UserInput/Methods/#userinputchangekey","title":"UserInput:ChangeKey","text":"<p><code>ChangeKey({Enum.KeyCode | Enum.UserInputType | string})</code></p> <p>Replace all currently registered keys with a new set</p> <ul> <li>@param Keys: Keys to register</li> </ul>"},{"location":"API/UserInput/Methods/#userinputaddkey","title":"UserInput:AddKey","text":"<p><code>AddKey({Enum.KeyCode | Enum.UserInputType | string})</code></p> <p>Add new keys to the existing registered set Duplicate keys are automatically ignored</p> <ul> <li>@param Keys: Keys to add</li> </ul>"},{"location":"API/UserInput/Methods/#userinputremovekey","title":"UserInput:RemoveKey","text":"<p><code>RemoveKey({Enum.KeyCode | Enum.UserInputType | string})</code></p> <p>Remove specific keys from the registered set</p> <ul> <li>@param Keys: Keys to remove</li> </ul>"},{"location":"API/UserInput/Methods/#userinputdisconnect","title":"UserInput:Disconnect","text":"<p>Note</p> <p>Multiple Disconnect function exist you will find everything about disconnection here</p>"},{"location":"API/UserInput/Methods/#disconnectpressed","title":"DisconnectPressed","text":"<p><code>DisconnectPressed</code></p> <p>Disconnect all callbacks connected to the KeyPressed signal </p>"},{"location":"API/UserInput/Methods/#disconnectreleased","title":"DisconnectReleased","text":"<p><code>DisconnectReleased</code></p> <p>Disconnect all callbacks connected to the KeyReleased signal </p>"},{"location":"API/UserInput/Methods/#disconnectmiddleup","title":"DisconnectMiddleUp","text":"<p><code>@MouseOnly - DisconnectMiddleUpSignal</code></p> <p>Disconnect the middle mouse button up signal</p>"},{"location":"API/UserInput/Methods/#disconnectmiddledown","title":"DisconnectMiddleDown","text":"<p><code>@MouseOnly - DisconnectMiddleDownSignal</code></p> <p>Disconnect the middle mouse button down signal</p>"},{"location":"API/UserInput/Methods/#disconnectscrolled","title":"DisconnectScrolled","text":"<p><code>@MouseOnly - DisconnectScrolledSignal</code> </p> <p>Disconnect the scroll signal from the mouse</p>"},{"location":"API/UserInput/Methods/#disconnectmoved","title":"DisconnectMoved","text":"<p><code>@MouseOnly - DisconnectMovedSignal</code></p> <p>Disconnect the signal when the mouse move</p>"},{"location":"API/UserInput/Methods/#disconnectall","title":"DisconnectAll","text":"<p><code>DisconnectAll</code></p> <p>Disconnect all signals</p>"},{"location":"API/UserInput/Methods/#userinputdestroy","title":"UserInput:Destroy()","text":"<p><code>Destroy</code></p> <p>Complete cleanup of the UserInput component  This should be called when the component is no longer needed</p>"},{"location":"API/UserInput/Methods/#alias","title":"Alias","text":"<pre><code>-- Constructor alias for convenience and consistency\nUserInput.New = UserInput.new\n\n-- Comprehensive method aliases for various naming conventions and case sensitivity\nComponent.pressed = Component.Pressed\nComponent.released = Component.Released\nComponent.changeInputType = Component.ChangeInputType\nComponent.changeInputtype = Component.ChangeInputType\nComponent.addKey = Component.AddKey\nComponent.addkey = Component.AddKey\nComponent.removeKey = Component.RemoveKey\nComponent.removekey = Component.RemoveKey\nComponent.middleUp = Component.MiddleUp\nComponent.middleup = Component.MiddleUp\nComponent.middleDown = Component.MiddleDown\nComponent.middledown = Component.MiddleDown\nComponent.scrolled = Component.Scrolled\nComponent.moved = Component.Moved\nComponent.disconnectPressed = Component.DisconnectPressed\nComponent.disconnectpressed = Component.DisconnectPressed\nComponent.disconnectReleased = Component.DisconnectReleased\nComponent.disconnectreleased = Component.DisconnectReleased\nComponent.disconnectScrolledSignal = Component.DisconnectScrolledSignal\nComponent.disconnectscrolledSignal = Component.DisconnectScrolledSignal\nComponent.disconnectMovedSignal = Component.DisconnectMovedSignal\nComponent.disconnectmovedSignal = Component.DisconnectMovedSignal\nComponent.disconnectMiddleUpSignal = Component.DisconnectMiddleUpSignal\nComponent.disconnectmiddleUpSignal = Component.DisconnectMiddleUpSignal\nComponent.discconectmiddleupSignal = Component.DisconnectMiddleUpSignal\nComponent.disconnectMiddleDownSignal = Component.DisconnectMiddleDownSignal\nComponent.disconnectmiddleDownSignal = Component.DisconnectMiddleDownSignal\nComponent.disconectmiddledownSignal = Component.DisconnectMiddleDownSignal\nComponent.disconnectAll = Component.DisconnectAll\nComponent.disconnectall = Component.DisconnectAll\nComponent.observe = Component.Observe\nComponent.getInputType = Component.GetInputType\nComponent.destroy = Component.Destroy\n\n-- Additional aliases for complete coverage\nComponent.Changekey = Component.ChangeKey\nComponent.ChangeKeys = Component.ChangeKey\nComponent.changeKeys = Component.ChangeKey\nComponent.Addkeys = Component.AddKey\nComponent.addkeys = Component.AddKey\nComponent.Removekeys = Component.RemoveKey\nComponent.removekeys = Component.RemoveKey\nComponent.Middleup = Component.MiddleUp\nComponent.Middledown = Component.MiddleDown\nComponent.Scroll = Component.Scrolled\nComponent.DisconnectScroll = Component.DisconnectScrolledSignal\nComponent.DisconnectMove = Component.DisconnectMovedSignal\nComponent.DisconnectMiddleDown = Component.DisconnectMiddleDownSignal\nComponent.ObserveInput = Component.Observe\nComponent.cleanup = Component.Destroy\n</code></pre>"},{"location":"API/UserInput/Mouse/","title":"Mouse","text":""},{"location":"API/UserInput/Mouse/#getting-started","title":"Getting Started","text":"<p>For mouse keys, you need to set <code>InputType</code> to <code>Mouse</code>, then you can use all mouse buttons.</p>"},{"location":"API/UserInput/Mouse/#mouse-object","title":"Mouse Object","text":"<pre><code>local MouseTest = UserInput.new({InputType = \"Mouse\", Keys = {\n    Enum.UserInputType.MouseButton3, -- Middle Mouse Button\n    Enum.UserInputType.MouseButton1 -- Left Mouse Button\n}})\n\nMouseTest:Pressed(function(key)\n    print(key)\nend)\n\nMouseTest:Released(function(key)\n    print(key)\nend)\n\n--@MouseOnly\nMouseTest:Scrolled(function(scrollAmount)\n    print(scrollAmount)\nend)\n\n--@MouseOnly\nMouseTest:MiddleUp(function(key)\n    print(key)\nend)\n\n--@MouseOnly\nMouseTest:MiddleDown(function(key)\n    print(key)\nend)\n\n--@MouseOnly\nMouseTest:Moved(function(pos)\n    print(pos)\nend)\n\n--@MouseOnly\nMouseTest:DisconnectScrolledSignal()\nMouseTest:DisconnectMiddleUpSignal()\nMouseTest:DisconnectMiddleDown()\nMouseTest:DisconnectMovedSignal()\n</code></pre> <p>This creates a Mouse Object. You can change the type with <code>ChangeInputType</code>.</p>"}]}